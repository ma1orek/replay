"use client";

import { useState, useCallback, useRef, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { 
  Loader2, 
  Trash2,
  Upload,
  Download,
  ChevronRight,
  ChevronLeft,
  Film,
  CheckCircle,
  ExternalLink,
  Monitor,
  Video,
  Code,
  Eye,
  Square,
  ChevronDown,
  User,
  Sparkles,
  Activity,
  Palette,
  FileInput,
  Send,
  Pencil,
  X,
  GitBranch,
  Box,
  Boxes,
  Layers,
  Layout,
  Type,
  MousePointer,
  Play,
  Pause,
  Check,
  Droplet,
  Paintbrush,
  ZoomIn,
  ZoomOut,
  RefreshCw,
  Smartphone,
  Crosshair,
  Clock,
  Plus,
  Copy,
  History,
  Lock,
  MoreVertical,
  GripVertical,
  Folder,
  FolderTree,
  FileCode,
  Search,
  Settings,
  Image as ImageIcon,
  Paperclip,
  LogOut
} from "lucide-react";
import { cn, generateId, formatDuration, updateProjectAnalytics } from "@/lib/utils";
import { transmuteVideoToCode, editCodeWithAI } from "@/actions/transmute";
import { getDatabaseContext, formatDatabaseContextForPrompt } from "@/lib/supabase/schema";
import Logo from "@/components/Logo";
import StyleInjector from "@/components/StyleInjector";
import { Highlight, themes } from "prism-react-renderer";
import { usePendingFlow } from "@/app/providers";
import { useAuth } from "@/lib/auth/context";
import { useCredits, CREDIT_COSTS } from "@/lib/credits/context";
import { useProfile } from "@/lib/profile/context";
import Image from "next/image";
import Avatar from "@/components/Avatar";
import AuthModal from "@/components/modals/AuthModal";
import OutOfCreditsModal from "@/components/modals/OutOfCreditsModal";
import FeedbackGateModal from "@/components/modals/FeedbackGateModal";
import ProjectSettingsModal from "@/components/ProjectSettingsModal";
import { Toast, useToast } from "@/components/Toast";
import Link from "next/link";
import type { CodeMode, FileNode, FileTreeFolder, FileTreeFile, CodeReferenceMap } from "@/types";

interface FlowItem {
  id: string;
  name: string;
  videoBlob: Blob;
  videoUrl: string;
  thumbnail?: string;
  duration: number;
  trimStart: number;
  trimEnd: number;
}

interface ArchNode {
  id: string;
  name: string;
  type: "page" | "component" | "section" | "element" | "interactive";
  description?: string;
  x: number;
  y: number;
  connections?: string[];
}

// Flow = PRODUCT MAP (not timeline) - what's possible, not what happened
// Shows CONFIRMED paths (from video) + POSSIBLE paths (detected nav items)
interface ProductFlowNode {
  id: string;
  name: string;
  type: "view" | "section" | "modal" | "state";
  description?: string;
  x: number;
  y: number;
  components?: string[];
  status: "observed" | "detected" | "possible" | "added"; // observed = shown in video, detected = in navigation but not visited, possible = reachable continuation, added = generated by AI
  confidence: "high" | "medium" | "low"; // Confidence level based on video evidence
}

interface ProductFlowEdge {
  id: string;
  from: string;
  to: string;
  label: string;
  type: "navigation" | "action" | "scroll" | "gated" | "possible";
  // navigation = thick solid line (route change)
  // scroll = thin solid line (in-page)
  // gated = dashed line with lock (auth/paywall required)
  // action = medium solid line (user action)
  // possible = dashed gray line (detected in nav, not implemented)
}

// UX Signals detected during analysis
interface UXSignal {
  type: "attention" | "imbalance" | "cta" | "navigation" | "mobile";
  label: string;
  value: string;
}

interface StyleInfo {
  colors: { name: string; value: string }[];
  fonts: { name: string; usage: string; weight: string; family: string }[];
  spacing: string;
  borderRadius: string;
  shadows: string;
}

// Generation history for persistence (saved to Supabase)
interface GenerationVersion {
  id: string;
  timestamp: number;
  label: string; // e.g., "Initial generation", "AI Edit: added header"
  code: string;
  flowNodes: ProductFlowNode[];
  flowEdges: ProductFlowEdge[];
  styleInfo: StyleInfo | null;
}

interface GenerationRecord {
  id: string;
  title: string;
  autoTitle: boolean;
  timestamp: number;
  status: "running" | "complete" | "failed";
  code: string | null;
  styleDirective: string;
  refinements: string;
  flowNodes: ProductFlowNode[];
  flowEdges: ProductFlowEdge[];
  styleInfo: StyleInfo | null;
  videoUrl?: string;
  thumbnailUrl?: string;
  versions?: GenerationVersion[]; // Version history
  publishedSlug?: string; // Persistent publish URL slug
  tokenUsage?: {
    promptTokens: number;
    candidatesTokens: number;
    totalTokens: number;
  };
  costCredits?: number;
}

type ViewMode = "preview" | "code" | "flow" | "design" | "input";

// Different loading messages for each tab - extended for longer generations
const STREAMING_MESSAGES_PREVIEW = [
  "Reconstructing user interface...",
  "Building visual components...",
  "Rendering pixel-perfect layout...",
  "Assembling responsive design...",
  "Crafting interactive elements...",
  "Applying style treatments...",
  "Polishing animations...",
  "Optimizing visual hierarchy...",
  "Finalizing preview render...",
  "Adding finishing touches...",
  "Rendering final output...",
  "Processing visual layers...",
  "Composing UI structure...",
  "Building interactive preview...",
  "Analyzing layout patterns...",
  "Structuring components...",
  "Generating responsive views...",
  "Fine-tuning visual elements...",
  "Completing preview generation...",
  "Almost there, perfecting details...",
  "Processing design tokens...",
  "Building component hierarchy...",
  "Applying responsive breakpoints...",
  "Generating hover states...",
  "Setting up interactions...",
  "Rendering shadow effects...",
  "Processing color palette...",
  "Building navigation structure...",
  "Finalizing button states...",
  "Applying micro-animations...",
  "Setting up form elements...",
  "Building card layouts...",
  "Processing image placements...",
  "Finalizing typography...",
  "Setting up grid system...",
  "Almost ready for preview...",
  "Completing UI assembly...",
  "Running final validation...",
  "Preview nearly complete...",
  "Just a moment more...",
];

const STREAMING_MESSAGES_CODE = [
  "Analyzing video structure...",
  "Extracting component patterns...",
  "Generating semantic HTML...",
  "Writing Tailwind classes...",
  "Structuring responsive code...",
  "Adding interactivity logic...",
  "Implementing animations...",
  "Optimizing for performance...",
  "Cleaning up code output...",
  "Finalizing code generation...",
  "Building component hierarchy...",
  "Processing UI patterns...",
  "Generating styled components...",
  "Adding responsive breakpoints...",
  "Implementing hover states...",
  "Creating animation keyframes...",
  "Structuring CSS modules...",
  "Optimizing bundle size...",
  "Validating HTML structure...",
  "Completing code generation...",
  "Processing component props...",
  "Building state management...",
  "Adding event handlers...",
  "Generating utility functions...",
  "Creating reusable hooks...",
  "Setting up component exports...",
  "Building layout system...",
  "Processing grid structure...",
  "Generating flex containers...",
  "Adding accessibility attributes...",
  "Creating form handlers...",
  "Building navigation logic...",
  "Processing image components...",
  "Adding loading states...",
  "Creating error boundaries...",
  "Building modal components...",
  "Processing dropdown menus...",
  "Almost finished coding...",
  "Running final code checks...",
  "Code generation nearly done...",
];

const STREAMING_MESSAGES_FLOW = [
  "Mapping user journey...",
  "Detecting navigation paths...",
  "Identifying entry points...",
  "Building flow topology...",
  "Connecting interaction nodes...",
  "Analyzing transition logic...",
  "Structuring product map...",
  "Detecting possible routes...",
  "Finalizing flow architecture...",
  "Preparing canvas render...",
  "Mapping screen transitions...",
  "Building navigation graph...",
  "Identifying user paths...",
  "Connecting UI states...",
  "Processing flow nodes...",
  "Generating edge connections...",
  "Analyzing page hierarchy...",
  "Building interaction map...",
  "Completing flow diagram...",
  "Rendering flow canvas...",
  "Analyzing click patterns...",
  "Detecting scroll behaviors...",
  "Mapping hover interactions...",
  "Building state transitions...",
  "Processing conditional flows...",
  "Generating decision trees...",
  "Analyzing user choices...",
  "Building branching logic...",
  "Processing parallel paths...",
  "Detecting loop patterns...",
  "Mapping exit points...",
  "Building entry conditions...",
  "Processing user triggers...",
  "Generating flow metadata...",
  "Building canvas layout...",
  "Positioning flow nodes...",
  "Calculating edge paths...",
  "Almost done with flow...",
  "Finalizing flow structure...",
  "Flow generation complete soon...",
];

const STREAMING_MESSAGES_DESIGN = [
  "Extracting color palette...",
  "Analyzing typography system...",
  "Detecting spacing patterns...",
  "Building design tokens...",
  "Mapping component styles...",
  "Identifying visual patterns...",
  "Structuring design system...",
  "Analyzing border & shadow...",
  "Finalizing style extraction...",
  "Preparing design overview...",
  "Processing color values...",
  "Detecting font families...",
  "Mapping spacing scale...",
  "Building shadow tokens...",
  "Analyzing radius patterns...",
  "Extracting gradient styles...",
  "Processing animation curves...",
  "Generating style variables...",
  "Completing design tokens...",
  "Finalizing design system...",
  "Processing primary colors...",
  "Analyzing accent hues...",
  "Building color scales...",
  "Detecting contrast ratios...",
  "Processing font weights...",
  "Analyzing line heights...",
  "Building type scale...",
  "Processing letter spacing...",
  "Detecting icon styles...",
  "Analyzing button styles...",
  "Processing input styles...",
  "Building card patterns...",
  "Detecting hover effects...",
  "Analyzing focus states...",
  "Processing active states...",
  "Building state tokens...",
  "Almost done with design...",
  "Finalizing design tokens...",
  "Design system nearly ready...",
  "Completing style analysis...",
];

// Default messages (used for general loading)
const STREAMING_MESSAGES = [
  "Scanning video frames...",
  "Extracting visual information...",
  "Identifying components...",
  "Detecting UI elements...",
  "Mapping interactions...",
  "Understanding transitions...",
  "Processing with Gemini AI...",
  "Generating optimized code...",
  "Applying style preferences...",
  "Finalizing output...",
  "Analyzing UI patterns...",
  "Processing visual data...",
  "Building component tree...",
  "Generating responsive layout...",
  "Adding interactivity...",
  "Optimizing performance...",
  "Cleaning up output...",
  "Validating structure...",
  "Completing generation...",
  "Almost done...",
  "Analyzing video content...",
  "Processing user interactions...",
  "Detecting click patterns...",
  "Mapping scroll behavior...",
  "Building hover states...",
  "Processing form elements...",
  "Generating button styles...",
  "Creating navigation logic...",
  "Building page structure...",
  "Processing image assets...",
  "Generating icon elements...",
  "Creating card components...",
  "Building modal dialogs...",
  "Processing dropdown menus...",
  "Generating list items...",
  "Creating table structures...",
  "Building footer elements...",
  "Processing header components...",
  "Almost finished generating...",
  "Just a few more seconds...",
];

const LogoIcon = ({ className, color = "currentColor" }: { className?: string; color?: string }) => (
  <svg className={className} viewBox="0 0 82 109" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M68.099 37.2285C78.1678 43.042 78.168 57.5753 68.099 63.3887L29.5092 85.668C15.6602 93.6633 0.510418 77.4704 9.40857 64.1836L17.4017 52.248C18.1877 51.0745 18.1876 49.5427 17.4017 48.3691L9.40857 36.4336C0.509989 23.1467 15.6602 6.95306 29.5092 14.9482L68.099 37.2285Z" stroke={color} strokeWidth="11.6182" strokeLinejoin="round"/>
    <rect x="34.054" y="98.6841" width="48.6555" height="11.6182" rx="5.80909" transform="rotate(-30 34.054 98.6841)" fill={color}/>
  </svg>
);

const getNodeIcon = (type: string) => {
  switch (type) {
    case "page": return Layout;
    case "component": return Box;
    case "section": return Layers;
    case "element": return Type;
    case "interactive": return MousePointer;
    default: return Box;
  }
};

export default function ReplayTool() {
  const { pending, clearPending } = usePendingFlow();
  const { user, isLoading: authLoading, signOut } = useAuth();
  const { totalCredits: userTotalCredits, wallet, membership, canAfford, refreshCredits } = useCredits();
  const { profile } = useProfile();
  const { toast, showToast, hideToast } = useToast();
  
  const [flows, setFlows] = useState<FlowItem[]>([]);
  const [styleDirective, setStyleDirective] = useState("Custom");
  const [styleReferenceImage, setStyleReferenceImage] = useState<{ url: string; name: string } | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [generatedCode, setGeneratedCode] = useState<string | null>(null);
  const [hasLoadedFromStorage, setHasLoadedFromStorage] = useState(false);
  const [displayedCode, setDisplayedCode] = useState<string>("");
  const [editableCode, setEditableCode] = useState<string>("");
  const [isCodeEditable, setIsCodeEditable] = useState(false);
  const [isStreamingCode, setIsStreamingCode] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [viewMode, setViewMode] = useState<ViewMode>("preview");
  const [selectedFlowId, setSelectedFlowId] = useState<string | null>(null);
  const [showUserMenu, setShowUserMenu] = useState(false);
  // streamingMessage state removed - loading handled in LoadingState component
  const [generationSessionId, setGenerationSessionId] = useState<string | null>(null); // Track current generation to hide old content
  
  // Auth/Credits modals
  const [showAuthModal, setShowAuthModal] = useState(false);
  const [showOutOfCreditsModal, setShowOutOfCreditsModal] = useState(false);
  const [showFeedbackModal, setShowFeedbackModal] = useState(false);
  const [hasShownFeedback, setHasShownFeedback] = useState(false);
  const [pendingAction, setPendingAction] = useState<"generate" | "edit" | null>(null);
  const [analysisDescription, setAnalysisDescription] = useState<string>("");
  const [editInput, setEditInput] = useState("");
  const [isMobilePreview, setIsMobilePreview] = useState(false);
  const [isPointAndEdit, setIsPointAndEdit] = useState(false);
  const [refinements, setRefinements] = useState("");
  const [contextImages, setContextImages] = useState<{ id: string; url: string; name: string; uploading?: boolean }[]>([]);
  const [analysisSection, setAnalysisSection] = useState<"style" | "layout" | "components">("style");
  const contextImageInputRef = useRef<HTMLInputElement>(null);
  
  // Mobile state - input visible by default
  const [mobilePanel, setMobilePanel] = useState<"input" | "preview" | "code" | "flow" | "design" | null>("input");
  const [showMobileMenu, setShowMobileMenu] = useState(false);
  
  // Live analysis state for "Matrix" view
  interface AnalysisPhase {
    palette: string[];
    typography: string;
    vibe: string;
    layout: string;
    container: string;
    responsive: string;
    components: { name: string; status: "waiting" | "generating" | "done" }[];
    stats?: { tech: string; componentCount: number; imageCount: number; theme: string };
    // UX Signals - subtle behavioral insights
    uxSignals?: UXSignal[];
    // Structure components (renamed from components for clarity)
    structureItems?: { name: string; status: "waiting" | "generating" | "done" }[];
  }
  const [analysisPhase, setAnalysisPhase] = useState<AnalysisPhase | null>(null);
  
  // Flow state = PRODUCT MAP (canvas with nodes/edges)
  const [flowNodes, setFlowNodes] = useState<ProductFlowNode[]>([]);
  const [flowEdges, setFlowEdges] = useState<ProductFlowEdge[]>([]);
  const [flowBuilding, setFlowBuilding] = useState(false);
  const [selectedFlowNode, setSelectedFlowNode] = useState<string | null>(null);
  const [showStructureInFlow, setShowStructureInFlow] = useState(false); // Toggle to show components under nodes
  const [showPossiblePaths, setShowPossiblePaths] = useState(true); // Toggle to show/hide possible paths in Flow
  const [generationComplete, setGenerationComplete] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [showFloatingEdit, setShowFloatingEdit] = useState(false);
  const [editImages, setEditImages] = useState<{ id: string; url: string; name: string; file?: File; uploading?: boolean }[]>([]);
  const [architecture, setArchitecture] = useState<ArchNode[]>([]);
  const [archBuilding, setArchBuilding] = useState(false);
  const [selectedArchNode, setSelectedArchNode] = useState<string | null>(null);
  const [styleInfo, setStyleInfo] = useState<StyleInfo | null>(null);
  const [archZoom, setArchZoom] = useState(1);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [selectedNodeModal, setSelectedNodeModal] = useState<ArchNode | null>(null);
  
  // Generation history for persistence  
  const [generations, setGenerations] = useState<GenerationRecord[]>([]);
  const [activeGeneration, setActiveGeneration] = useState<GenerationRecord | null>(null);
  const [generationTitle, setGenerationTitle] = useState<string>("Untitled Project");
  const [showHistoryMode, setShowHistoryMode] = useState(false);
  const [showProjectSettings, setShowProjectSettings] = useState(false);
  const [historyMenuOpen, setHistoryMenuOpen] = useState<string | null>(null);
  const [renamingId, setRenamingId] = useState<string | null>(null);
  const [renameValue, setRenameValue] = useState("");
  const [historySearch, setHistorySearch] = useState("");
  const [expandedVersions, setExpandedVersions] = useState<string | null>(null); // Which generation's versions are shown
  
  // Publishing state
  const [isPublishing, setIsPublishing] = useState(false);
  const [publishedUrl, setPublishedUrl] = useState<string | null>(null);
  const [showPublishModal, setShowPublishModal] = useState(false);
  
  // Dragging state for flow nodes
  const [draggingNodeId, setDraggingNodeId] = useState<string | null>(null);
  const dragStartPos = useRef({ x: 0, y: 0, nodeX: 0, nodeY: 0 });
  
  // Code tab state - Single-file vs Componentized mode
  const [codeMode, setCodeMode] = useState<CodeMode>("single-file");
  const [generatedFiles, setGeneratedFiles] = useState<FileNode[]>([]);
  const [activeFilePath, setActiveFilePath] = useState<string>("/pages/index.html");
  const [generatingFilePath, setGeneratingFilePath] = useState<string | null>(null); // Track which file is being generated
  const [codeReferenceMap, setCodeReferenceMap] = useState<CodeReferenceMap[]>([]);
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set(["/pages", "/components"]));
  const [highlightedLines, setHighlightedLines] = useState<{ start: number; end: number } | null>(null);
  
  // Canvas pan state for architecture - start centered
  const [canvasPan, setCanvasPan] = useState({ x: -200, y: 50 });
  const [isPanning, setIsPanning] = useState(false);
  const panStartRef = useRef({ x: 0, y: 0, panX: 0, panY: 0 });
  const archCanvasRef = useRef<HTMLDivElement>(null);
  const editInputRef = useRef<HTMLInputElement>(null);
  const titleInputRef = useRef<HTMLInputElement>(null);
  const previewIframeRef = useRef<HTMLIFrameElement>(null);
  const [selectedElement, setSelectedElement] = useState<string | null>(null);
  
  // Video player state
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [isDraggingTrim, setIsDraggingTrim] = useState<"start" | "end" | null>(null);
  const [trimPreviewTime, setTrimPreviewTime] = useState<number | null>(null);
  
  const [isRecording, setIsRecording] = useState(false);
  const [recordingDuration, setRecordingDuration] = useState(0);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const trimBarRef = useRef<HTMLDivElement>(null);
  
  const fileInputRef = useRef<HTMLInputElement>(null);
  const analysisRef = useRef<HTMLDivElement>(null);
  const codeContainerRef = useRef<HTMLDivElement>(null);

  const selectedFlow = flows.find(f => f.id === selectedFlowId);

  // Regenerate thumbnail from video URL (for restored flows)
  const regenerateThumbnail = useCallback(async (flowId: string, videoUrl: string) => {
    try {
      const video = document.createElement("video");
      video.crossOrigin = "anonymous";
      video.preload = "metadata";
      video.muted = true;
      
      video.onloadeddata = () => {
        video.currentTime = 0.5; // Seek to get a good frame
      };
      
      video.onseeked = () => {
        try {
          const canvas = document.createElement("canvas");
          const vw = video.videoWidth || 320;
          const vh = video.videoHeight || 180;
          canvas.width = 160;
          canvas.height = Math.round((160 / vw) * vh) || 90;
          const ctx = canvas.getContext("2d");
          if (ctx && vw > 0 && vh > 0) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL("image/jpeg", 0.8);
            if (dataUrl.length > 1000) {
              setFlows(prev => prev.map(f => 
                f.id === flowId ? { ...f, thumbnail: dataUrl } : f
              ));
            }
          }
        } catch (e) {
          console.error("Failed to regenerate thumbnail:", e);
        }
      };
      
      video.src = videoUrl;
      video.load();
    } catch (e) {
      console.error("Failed to load video for thumbnail:", e);
    }
  }, []);

  // Get suggestions for @ mentions
  const getSuggestions = () => {
    if (!editInput.includes("@")) return [];
    const lastAt = editInput.lastIndexOf("@");
    const query = editInput.slice(lastAt + 1).toLowerCase();
    return architecture.filter(node => 
      node.id.toLowerCase().includes(query) || 
      node.name.toLowerCase().includes(query)
    ).slice(0, 5);
  };

  const suggestions = getSuggestions();

  // Show suggestions when typing @
  useEffect(() => {
    setShowSuggestions(editInput.includes("@") && suggestions.length > 0 && showFloatingEdit);
  }, [editInput, suggestions.length, showFloatingEdit]);

  // Get messages based on current tab
  const getStreamingMessages = useCallback(() => {
    switch (viewMode) {
      case "preview": return STREAMING_MESSAGES_PREVIEW;
      case "code": return STREAMING_MESSAGES_CODE;
      case "flow": return STREAMING_MESSAGES_FLOW;
      case "design": return STREAMING_MESSAGES_DESIGN;
      default: return STREAMING_MESSAGES;
    }
  }, [viewMode]);

  // Get messages based on mobile panel
  const getMobileStreamingMessages = useCallback(() => {
    switch (mobilePanel) {
      case "preview": return STREAMING_MESSAGES_PREVIEW;
      case "code": return STREAMING_MESSAGES_CODE;
      case "flow": return STREAMING_MESSAGES_FLOW;
      case "design": return STREAMING_MESSAGES_DESIGN;
      default: return STREAMING_MESSAGES;
    }
  }, [mobilePanel]);

  // Track if we have pending code to show (generation finished while tab was hidden)
  const pendingCodeRef = useRef<string | null>(null);
  const streamingCompleteRef = useRef(false);
  const generationStartTimeRef = useRef<number | null>(null);
  
  // Max generation time (6 minutes on mobile, 4 on desktop) - after this, consider it stuck/failed
  const isMobileDevice = typeof navigator !== 'undefined' && /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const MAX_GENERATION_TIME_MS = isMobileDevice ? 6 * 60 * 1000 : 4 * 60 * 1000;
  
  // Complete generation and show results
  const completeGeneration = useCallback((code: string) => {
    if (streamingCompleteRef.current) return;
    streamingCompleteRef.current = true;
    pendingCodeRef.current = null;
    generationStartTimeRef.current = null;
    
    console.log("Completing generation - showing result immediately");
    
    setDisplayedCode(code);
    setEditableCode(code);
    setIsStreamingCode(false);
    setIsProcessing(false);
    setGenerationComplete(true);
    setViewMode("preview");
    
    // Mark all components as done
    setAnalysisPhase(prev => prev ? {
      ...prev,
      components: prev.components.map(c => ({ ...c, status: "done" as const }))
    } : prev);
    
    // Auto-switch to preview on mobile
    if (typeof window !== "undefined" && window.innerWidth < 768) {
      setMobilePanel("preview");
    }
    
    // Generate description
    const description = generateAnalysisDescription(code, styleDirective);
    typeText(description, (typed) => setAnalysisDescription(typed), 15);
    
    // Update preview URL
    const blob = new Blob([code], { type: "text/html" });
    setPreviewUrl(URL.createObjectURL(blob));
  }, [styleDirective]);
  
  // Reset stuck generation
  const resetStuckGeneration = useCallback(() => {
    console.log("Resetting stuck generation");
    setIsProcessing(false);
    setIsStreamingCode(false);
    generationStartTimeRef.current = null;
    pendingCodeRef.current = null;
    streamingCompleteRef.current = false;
    showToast("Generation timed out. Please try again.", "error");
  }, [showToast]);
  
  // Handle tab visibility change - show pending result or detect stuck generation
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (!document.hidden) {
        // Tab became visible
        
        // Check if we have pending code to show
        if (pendingCodeRef.current && !streamingCompleteRef.current) {
          console.log("Tab visible - showing pending generation result");
          completeGeneration(pendingCodeRef.current);
          return;
        }
        
        // Check if generation is stuck (running too long)
        if (generationStartTimeRef.current && isProcessing) {
          const elapsedTime = Date.now() - generationStartTimeRef.current;
          console.log("Tab visible - checking generation status, elapsed:", elapsedTime / 1000, "s");
          
          if (elapsedTime > MAX_GENERATION_TIME_MS) {
            console.log("Generation stuck - elapsed time exceeds max");
            resetStuckGeneration();
          }
        }
      }
    };
    
    document.addEventListener("visibilitychange", handleVisibilityChange);
    window.addEventListener("focus", handleVisibilityChange);
    
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("focus", handleVisibilityChange);
    };
  }, [completeGeneration, resetStuckGeneration, isProcessing]);
  
  // Auto-timeout for stuck generations (runs every 30s)
  useEffect(() => {
    if (!isProcessing || !generationStartTimeRef.current) return;
    
    const checkInterval = setInterval(() => {
      if (generationStartTimeRef.current) {
        const elapsed = Date.now() - generationStartTimeRef.current;
        if (elapsed > MAX_GENERATION_TIME_MS) {
          console.log("Generation timeout - auto-resetting");
          resetStuckGeneration();
        }
      }
    }, 30000); // Check every 30 seconds
    
    return () => clearInterval(checkInterval);
  }, [isProcessing, resetStuckGeneration]);

  // When new code arrives, either stream it or mark as pending
  useEffect(() => {
    if (!generatedCode || !isStreamingCode) return;
    
    // Reset completion flag for new generation
    streamingCompleteRef.current = false;
    
    // If tab is hidden, store as pending and complete immediately (state-wise)
    if (document.hidden) {
      console.log("Tab hidden - storing code as pending, will show when visible");
      pendingCodeRef.current = generatedCode;
      // Don't animate, just mark internally as ready
      // The visibility handler will show it when user returns
      return;
    }
    
    // Tab is visible - animate the streaming
    let index = 0;
    const chunkSize = 20;
    let lastTime = Date.now();
    
    const interval = setInterval(() => {
      if (streamingCompleteRef.current) {
        clearInterval(interval);
        return;
      }
      
      const now = Date.now();
      
      // If tab became hidden, store as pending and stop
      if (document.hidden) {
        console.log("Tab became hidden - storing pending code");
        pendingCodeRef.current = generatedCode;
        clearInterval(interval);
        return;
      }
      
      // Fast-forward if there was a gap
      const elapsed = now - lastTime;
      if (elapsed > 200) {
        completeGeneration(generatedCode);
        clearInterval(interval);
        return;
      }
      lastTime = now;
      
      if (index < generatedCode.length) {
        setDisplayedCode(generatedCode.slice(0, index + chunkSize));
        setEditableCode(generatedCode.slice(0, index + chunkSize));
        index += chunkSize;
        if (codeContainerRef.current) codeContainerRef.current.scrollTop = codeContainerRef.current.scrollHeight;
      } else {
        completeGeneration(generatedCode);
        clearInterval(interval);
      }
    }, 8);
    
    return () => clearInterval(interval);
  }, [generatedCode, isStreamingCode, completeGeneration]);
  
  // Show feedback modal after generation (separate effect)
  useEffect(() => {
    if (generationComplete && !hasShownFeedback) {
      const timer = setTimeout(() => {
        setShowFeedbackModal(true);
        setHasShownFeedback(true);
        localStorage.setItem("replay_feedback_shown", "true");
      }, 10000);
      return () => clearTimeout(timer);
    }
  }, [generationComplete, hasShownFeedback]);

  useEffect(() => {
    return () => {
      if (streamRef.current) streamRef.current.getTracks().forEach(track => track.stop());
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, []);

  // Load flows from localStorage on mount
  useEffect(() => {
    try {
      const savedFlows = localStorage.getItem("replay_flows");
      const savedCode = localStorage.getItem("replay_generated_code");
      const savedStyle = localStorage.getItem("replay_style");
      const savedRefinements = localStorage.getItem("replay_refinements");
      const savedHistory = localStorage.getItem("replay_generation_history");
      const savedFlowNodes = localStorage.getItem("replay_flow_nodes");
      const savedFlowEdges = localStorage.getItem("replay_flow_edges");
      const savedStyleInfo = localStorage.getItem("replay_style_info");
      const savedTitle = localStorage.getItem("replay_generation_title");
      const savedAnalysis = localStorage.getItem("replay_analysis_phase");
      const savedAnalysisDesc = localStorage.getItem("replay_analysis_description");
      const savedFeedbackShown = localStorage.getItem("replay_feedback_shown");
      
      if (savedFeedbackShown === "true") {
        setHasShownFeedback(true);
      }
      
      if (savedFlows) {
        const parsed = JSON.parse(savedFlows);
        console.log("Loaded flows from localStorage:", parsed.map((f: FlowItem) => ({
          id: f.id,
          name: f.name,
          hasVideoUrl: !!f.videoUrl,
          videoUrlStart: f.videoUrl?.substring(0, 50),
          hasThumbnail: !!f.thumbnail,
          thumbnailLength: f.thumbnail?.length || 0
        })));
        
        // Filter out any flows with invalid video URLs (blob URLs don't persist)
        const validFlows = parsed.filter((f: FlowItem) => f.videoUrl && !f.videoUrl.startsWith("blob:"));
        if (validFlows.length > 0) {
          // Restore flows with their thumbnails, regenerate if missing
          const flowsWithThumbnails = validFlows.map((f: FlowItem) => {
            // Create a new videoBlob placeholder (we can't restore the actual blob)
            const restoredFlow = {
              ...f,
              videoBlob: new Blob(), // Placeholder - actual video will be fetched from URL if needed
            };
            
            // Only regenerate thumbnail if it's missing
            if (!f.thumbnail && f.videoUrl) {
              console.log("Regenerating thumbnail for flow:", f.name);
              regenerateThumbnail(f.id, f.videoUrl);
            }
            return restoredFlow;
          });
          setFlows(flowsWithThumbnails);
          setSelectedFlowId(validFlows[0].id);
        }
      }
      
      // Also try to restore flow from the most recent generation if no valid flows
      if (savedHistory) {
        const history: GenerationRecord[] = JSON.parse(savedHistory);
        const mostRecent = history.find(g => g.videoUrl && g.status === "complete");
        if (mostRecent && mostRecent.videoUrl) {
          // Check if we already have this flow
          const savedFlowsParsed = savedFlows ? JSON.parse(savedFlows) : [];
          const alreadyHaveFlow = savedFlowsParsed.some((f: FlowItem) => f.videoUrl === mostRecent.videoUrl);
          
          if (!alreadyHaveFlow) {
            const restoredFlow: FlowItem = {
              id: generateId(),
              name: mostRecent.title || "Recording",
              videoBlob: new Blob(),
              videoUrl: mostRecent.videoUrl,
              thumbnail: mostRecent.thumbnailUrl || "",
              duration: 30,
              trimStart: 0,
              trimEnd: 30,
            };
            setFlows(prev => prev.length > 0 ? prev : [restoredFlow]);
            setSelectedFlowId(prev => prev || restoredFlow.id);
          }
        }
      }
      if (savedCode) {
        setGeneratedCode(savedCode);
        setDisplayedCode(savedCode);
        setEditableCode(savedCode);
        // Create preview URL
        const blob = new Blob([savedCode], { type: "text/html" });
        setPreviewUrl(URL.createObjectURL(blob));
        setGenerationComplete(true);
      }
      if (savedStyle) setStyleDirective(savedStyle);
      if (savedRefinements) setRefinements(savedRefinements);
      if (savedHistory) {
        const parsedHistory: GenerationRecord[] = JSON.parse(savedHistory);
        setGenerations(parsedHistory);
        
        // Find and set active generation (most recent with code)
        const mostRecent = parsedHistory.find(g => g.code && g.status === "complete");
        if (mostRecent) {
          setActiveGeneration(mostRecent);
          console.log('[localStorage] Restored activeGeneration:', mostRecent.id, 'publishedSlug:', mostRecent.publishedSlug);
        }
      }
      if (savedFlowNodes) setFlowNodes(JSON.parse(savedFlowNodes));
      if (savedFlowEdges) setFlowEdges(JSON.parse(savedFlowEdges));
      if (savedStyleInfo) setStyleInfo(JSON.parse(savedStyleInfo));
      if (savedTitle) setGenerationTitle(savedTitle);
      if (savedAnalysis) setAnalysisPhase(JSON.parse(savedAnalysis));
      if (savedAnalysisDesc) setAnalysisDescription(savedAnalysisDesc);
      
      setHasLoadedFromStorage(true);
    } catch (e) {
      console.error("Error loading from localStorage:", e);
      setHasLoadedFromStorage(true);
    }
  }, []);

  // Save flows to localStorage (but not blob URLs - they don't persist)
  useEffect(() => {
    if (!hasLoadedFromStorage) return; // Don't save until we've loaded
    
    try {
      // Don't save blob URLs as they won't work after reload
      const flowsToSave = flows.map(f => ({
        ...f,
        // Keep data URLs (base64 thumbnails), but clear blob URLs
        videoUrl: f.videoUrl?.startsWith("blob:") ? "" : f.videoUrl,
        // Keep data: URLs for thumbnails (base64), only clear blob: URLs
        thumbnail: f.thumbnail?.startsWith("data:") ? f.thumbnail : (f.thumbnail?.startsWith("blob:") ? "" : f.thumbnail),
        // Don't save the videoBlob - it's not serializable
        videoBlob: undefined,
      })).filter(f => f.videoUrl); // Only save flows with valid URLs
      
      if (flowsToSave.length > 0) {
        console.log("Saving flows to localStorage:", flowsToSave.map(f => ({ 
          id: f.id, 
          name: f.name,
          hasVideoUrl: !!f.videoUrl, 
          hasThumbnail: !!f.thumbnail,
          thumbnailLength: f.thumbnail?.length || 0
        })));
      }
      
      localStorage.setItem("replay_flows", JSON.stringify(flowsToSave));
    } catch (e) {
      console.error("Error saving flows:", e);
    }
  }, [flows, hasLoadedFromStorage]);

  // Save generated code to localStorage
  useEffect(() => {
    if (!hasLoadedFromStorage || !generatedCode) return;
    try {
      localStorage.setItem("replay_generated_code", generatedCode);
    } catch (e) {
      console.error("Error saving code:", e);
    }
  }, [generatedCode, hasLoadedFromStorage]);

  // Save style to localStorage
  useEffect(() => {
    if (!hasLoadedFromStorage) return;
    try {
      localStorage.setItem("replay_style", styleDirective);
      localStorage.setItem("replay_refinements", refinements);
    } catch (e) {
      console.error("Error saving style:", e);
    }
  }, [styleDirective, refinements, hasLoadedFromStorage]);
  
  // Save flow nodes and edges to localStorage
  useEffect(() => {
    if (!hasLoadedFromStorage || flowNodes.length === 0) return;
    try {
      localStorage.setItem("replay_flow_nodes", JSON.stringify(flowNodes));
      localStorage.setItem("replay_flow_edges", JSON.stringify(flowEdges));
    } catch (e) {
      console.error("Error saving flow:", e);
    }
  }, [flowNodes, flowEdges, hasLoadedFromStorage]);
  
  // Save style info to localStorage
  useEffect(() => {
    if (!hasLoadedFromStorage || !styleInfo) return;
    try {
      localStorage.setItem("replay_style_info", JSON.stringify(styleInfo));
    } catch (e) {
      console.error("Error saving style info:", e);
    }
  }, [styleInfo, hasLoadedFromStorage]);
  
  // Save generation history to localStorage - with size limits
  useEffect(() => {
    if (!hasLoadedFromStorage || generations.length === 0) return;
    try {
      // Only keep last 5 generations to prevent QuotaExceededError
      // Each generation with code can be 50-100KB
      const recentHistory = generations.slice(-5).map(gen => ({
        ...gen,
        // Limit code size in localStorage to prevent quota issues
        code: gen.code?.substring(0, 50000) || '', // Max 50KB per generation
        versions: gen.versions?.slice(-3).map(v => ({
          ...v,
          code: v.code?.substring(0, 30000) || '', // Max 30KB per version
        })) || [],
      }));
      localStorage.setItem("replay_generation_history", JSON.stringify(recentHistory));
    } catch (e) {
      console.error("Error saving generation history:", e);
      // If quota exceeded, try to clear old data
      try {
        localStorage.removeItem("replay_generation_history");
        const minimalHistory = generations.slice(-2).map(gen => ({
          id: gen.id,
          title: gen.title,
          timestamp: gen.timestamp,
          publishedSlug: gen.publishedSlug,
          code: '', // Don't save code
          versions: [],
        }));
        localStorage.setItem("replay_generation_history", JSON.stringify(minimalHistory));
      } catch (e2) {
        console.error("Failed to save even minimal history:", e2);
      }
    }
  }, [generations, hasLoadedFromStorage]);
  
  // Sync generations with Supabase when user is logged in - Supabase is source of truth
  useEffect(() => {
    if (!user || !hasLoadedFromStorage) return;
    
    // Fetch generations from Supabase - Supabase is the primary source of truth
    const fetchFromSupabase = async () => {
      try {
        const response = await fetch("/api/generations");
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.generations) {
            // Supabase is the source of truth - just use it directly
            const supabaseGenerations = data.generations;
            
            // Get current local generations to check for any that aren't synced yet
            const localStorageData = localStorage.getItem("replay_generation_history");
            const localGenerations: GenerationRecord[] = localStorageData ? JSON.parse(localStorageData) : [];
            
            // Create map of local generations for quick lookup
            const localGenMap = new Map(localGenerations.map(g => [g.id, g]));
            
            // Find local generations that aren't in Supabase yet (just created)
            const supabaseIds = new Set(supabaseGenerations.map((g: GenerationRecord) => g.id));
            const unsyncedLocal = localGenerations.filter(g => !supabaseIds.has(g.id) && g.status === "complete");
            
            // Merge Supabase data with local data - preserve local publishedSlug if Supabase doesn't have it
            const mergedSupabase = supabaseGenerations.map((supGen: GenerationRecord) => {
              const localGen = localGenMap.get(supGen.id);
              // If local has publishedSlug but Supabase doesn't, keep the local one
              if (localGen?.publishedSlug && !supGen.publishedSlug) {
                return { ...supGen, publishedSlug: localGen.publishedSlug };
              }
              return supGen;
            });
            
            // Merge: Supabase data (with local slugs preserved) + unsynced local, limit to 50
            const merged = [...mergedSupabase, ...unsyncedLocal]
              .sort((a, b) => b.timestamp - a.timestamp)
              .slice(0, 50);
            
            // Always update to ensure sync
            setGenerations(merged);
            localStorage.setItem("replay_generation_history", JSON.stringify(merged));
            
            // Push any unsynced local generations to Supabase
            for (const gen of unsyncedLocal) {
              try {
                await fetch("/api/generations", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(gen),
                });
              } catch (e) {
                console.error("Error pushing local generation to Supabase:", e);
              }
            }
          }
        }
      } catch (e) {
        console.error("Error syncing with Supabase:", e);
      }
    };
    
    // Initial fetch
    fetchFromSupabase();
    
    // Set up periodic sync (every 15 seconds) and on visibility change
    const intervalId = setInterval(fetchFromSupabase, 15000);
    
    // Sync when tab becomes visible again (user switches back from mobile to PC or vice versa)
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        fetchFromSupabase();
      }
    };
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Sync on window focus
    const handleFocus = () => fetchFromSupabase();
    window.addEventListener('focus', handleFocus);
    
    return () => {
      clearInterval(intervalId);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('focus', handleFocus);
    };
  }, [user, hasLoadedFromStorage]);
  
  // Save active generation to Supabase when complete
  // Track failed saves to prevent spam
  const failedSavesRef = useRef<Set<string>>(new Set());
  
  const saveGenerationToSupabase = useCallback(async (gen: GenerationRecord) => {
    if (!user) {
      return;
    }
    
    // Don't retry if already failed for this generation
    if (failedSavesRef.current.has(gen.id)) {
      return;
    }
    
    try {
      const response = await fetch("/api/generations", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(gen),
      });
      
      const data = await response.json();
      if (!response.ok) {
        console.error("Error saving generation:", data);
        // Mark as failed to prevent retries
        failedSavesRef.current.add(gen.id);
      }
    } catch (e) {
      console.error("Error saving to Supabase:", e);
      failedSavesRef.current.add(gen.id);
    }
  }, [user]);
  
  // Save generation title to localStorage
  useEffect(() => {
    if (!hasLoadedFromStorage) return;
    try {
      localStorage.setItem("replay_generation_title", generationTitle);
    } catch (e) {
      console.error("Error saving title:", e);
    }
  }, [generationTitle, hasLoadedFromStorage]);
  
  // Save analysis phase to localStorage
  useEffect(() => {
    if (!hasLoadedFromStorage || !analysisPhase) return;
    try {
      localStorage.setItem("replay_analysis_phase", JSON.stringify(analysisPhase));
    } catch (e) {
      console.error("Error saving analysis phase:", e);
    }
  }, [analysisPhase, hasLoadedFromStorage]);
  
  // Save analysis description to localStorage
  useEffect(() => {
    if (!hasLoadedFromStorage || !analysisDescription) return;
    try {
      localStorage.setItem("replay_analysis_description", analysisDescription);
    } catch (e) {
      console.error("Error saving analysis description:", e);
    }
  }, [analysisDescription, hasLoadedFromStorage]);
  
  // Update active generation when code/flow changes (for persistence)
  useEffect(() => {
    if (!activeGeneration || !generatedCode || !generationComplete) return;
    
    // Update the active generation with latest state
    const updatedGen: GenerationRecord = {
      ...activeGeneration,
      code: generatedCode,
      flowNodes: flowNodes,
      flowEdges: flowEdges,
      styleInfo: styleInfo,
      styleDirective: styleDirective,
      title: generationTitle || activeGeneration.title,
      status: "complete"
    };
    
    setGenerations(prev => prev.map(g => g.id === activeGeneration.id ? updatedGen : g));
    
    // Sync to Supabase
    saveGenerationToSupabase(updatedGen);
  }, [generatedCode, flowNodes, flowEdges, styleInfo, styleDirective, generationTitle, generationComplete, activeGeneration?.id, saveGenerationToSupabase]);

  // Video time update
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;
    const handleTimeUpdate = () => setCurrentTime(video.currentTime);
    video.addEventListener("timeupdate", handleTimeUpdate);
    return () => video.removeEventListener("timeupdate", handleTimeUpdate);
  }, [selectedFlowId]);

  // Close history menu when clicking outside
  useEffect(() => {
    if (!historyMenuOpen) return;
    const handleClick = () => setHistoryMenuOpen(null);
    document.addEventListener("click", handleClick);
    return () => document.removeEventListener("click", handleClick);
  }, [historyMenuOpen]);

  // Point-and-edit: listen for messages from iframe
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'element-selected') {
        const { tagName, id, className, textContent } = event.data;
        // Build a descriptive element reference (not CSS selector format)
        let elementDesc = '';
        const tag = tagName?.toLowerCase() || 'element';
        
        if (textContent && textContent.length > 0 && textContent.length < 40) {
          // Use text content as primary identifier - most intuitive
          elementDesc = `the "${textContent.substring(0, 35).trim()}" ${tag}`;
        } else if (id) {
          elementDesc = `the ${tag} with id "${id}"`;
        } else if (className) {
          const firstClass = className.split(' ')[0];
          elementDesc = `the ${tag} with class "${firstClass}"`;
        } else {
          elementDesc = `the ${tag} element`;
        }
        
        setSelectedElement(elementDesc);
        // Don't use @ - just describe the element naturally
        // Only change if not currently editing
        if (!isEditing) {
          setEditInput(`For ${elementDesc}: `);
        }
        setIsPointAndEdit(false);
        editInputRef.current?.focus();
      }
    };
    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, []);

  // Inject pointer script into iframe when point-and-edit is enabled
  useEffect(() => {
    if (!isPointAndEdit || !previewIframeRef.current) return;
    
    const iframe = previewIframeRef.current;
    const injectScript = () => {
      try {
        const doc = iframe.contentDocument || iframe.contentWindow?.document;
        if (!doc) return;
        
        // Check if already injected
        if (doc.getElementById('point-and-edit-script')) return;
        
        const script = doc.createElement('script');
        script.id = 'point-and-edit-script';
        script.textContent = `
          (function() {
            let hovered = null;
            const overlay = document.createElement('div');
            overlay.id = 'point-edit-overlay';
            overlay.style.cssText = 'position:fixed;pointer-events:none;border:2px solid #FF6E3C;background:rgba(255,110,60,0.1);z-index:99999;transition:all 0.1s ease;display:none;';
            document.body.appendChild(overlay);
            
            document.addEventListener('mousemove', function(e) {
              const el = document.elementFromPoint(e.clientX, e.clientY);
              if (el && el !== hovered && el !== overlay) {
                hovered = el;
                const rect = el.getBoundingClientRect();
                overlay.style.display = 'block';
                overlay.style.left = rect.left + 'px';
                overlay.style.top = rect.top + 'px';
                overlay.style.width = rect.width + 'px';
                overlay.style.height = rect.height + 'px';
              }
            });
            
            document.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              const el = document.elementFromPoint(e.clientX, e.clientY);
              if (el && el !== overlay) {
                window.parent.postMessage({
                  type: 'element-selected',
                  tagName: el.tagName,
                  id: el.id,
                  className: el.className,
                  textContent: el.textContent?.trim().substring(0, 50)
                }, '*');
              }
            }, true);
          })();
        `;
        doc.body.appendChild(script);
        
        // Add cursor style
        const style = doc.createElement('style');
        style.id = 'point-and-edit-style';
        style.textContent = 'body, body * { cursor: crosshair !important; }';
        doc.head.appendChild(style);
      } catch (e) {
        console.log('Cannot inject into iframe:', e);
      }
    };
    
    // Wait for iframe to load
    if (iframe.contentDocument?.readyState === 'complete') {
      injectScript();
    } else {
      iframe.addEventListener('load', injectScript);
      return () => iframe.removeEventListener('load', injectScript);
    }
  }, [isPointAndEdit, previewUrl]);

  // Clean up pointer script when disabled
  useEffect(() => {
    if (isPointAndEdit || !previewIframeRef.current) return;
    try {
      const doc = previewIframeRef.current.contentDocument;
      if (doc) {
        doc.getElementById('point-and-edit-script')?.remove();
        doc.getElementById('point-and-edit-style')?.remove();
        doc.getElementById('point-edit-overlay')?.remove();
      }
    } catch (e) { /* ignore */ }
  }, [isPointAndEdit]);

  // Build architecture from code - better positioning with no overlaps
  const buildArchitectureLive = async (code: string) => {
    setArchBuilding(true);
    setArchitecture([]);
    
    const addNode = async (node: ArchNode) => {
      await new Promise(r => setTimeout(r, 120));
      setArchitecture(prev => [...prev, node]);
    };
    
    // Better layout - tree structure with proper spacing
    const centerX = 400;
    let currentY = 40;
    const rowHeight = 120;
    const colWidth = 250;
    
    // Analyze code for smarter naming
    const hasNav = /<nav/i.test(code);
    const hasHeader = /<header/i.test(code);
    const hasSidebar = /sidebar|aside/i.test(code);
    const hasHero = /hero|banner|jumbotron/i.test(code);
    const hasCards = /card/gi.test(code);
    const hasForms = /<form/i.test(code);
    const hasTable = /<table/i.test(code);
    
    await addNode({ id: "root", name: "Document", type: "page", description: "HTML root", x: centerX, y: currentY, connections: [] });
    currentY += rowHeight;
    
    // Row 2: Layout structure
    const row2Nodes: string[] = [];
    if (hasNav || hasHeader) {
      await addNode({ id: "nav", name: hasNav ? "Navigation" : "Header", type: "component", description: hasNav ? "Site navigation menu" : "Page header", x: centerX - colWidth, y: currentY, connections: ["root"] });
      row2Nodes.push("nav");
    }
    
    await addNode({ id: "content", name: "Content Area", type: "section", description: "Main page content", x: centerX, y: currentY, connections: ["root"] });
    row2Nodes.push("content");
    
    if (hasSidebar) {
      await addNode({ id: "sidebar", name: "Sidebar", type: "component", description: "Side navigation", x: centerX + colWidth, y: currentY, connections: ["root"] });
    }
    
    currentY += rowHeight;
    
    // Row 3: Content sections
    const row3Nodes: { id: string; name: string; desc: string }[] = [];
    if (hasHero) row3Nodes.push({ id: "hero", name: "Hero Section", desc: "Main visual banner" });
    if (hasCards) row3Nodes.push({ id: "cards", name: "Card Grid", desc: "Content cards layout" });
    if (hasForms) row3Nodes.push({ id: "forms", name: "Form Block", desc: "User input forms" });
    if (hasTable) row3Nodes.push({ id: "table", name: "Data Table", desc: "Tabular data display" });
    
    // Add generic sections if none detected
    const sections = (code.match(/<section/gi) || []).length;
    if (row3Nodes.length === 0 && sections > 0) {
      for (let i = 0; i < Math.min(sections, 3); i++) {
        row3Nodes.push({ id: `section-${i}`, name: `Section ${i + 1}`, desc: "Content section" });
      }
    }
    
    const spacing3 = colWidth;
    const startX3 = centerX - ((row3Nodes.length - 1) * spacing3) / 2;
    for (let i = 0; i < row3Nodes.length; i++) {
      await addNode({ 
        id: row3Nodes[i].id, 
        name: row3Nodes[i].name, 
        type: "component",
        description: row3Nodes[i].desc,
        x: startX3 + (i * spacing3), 
        y: currentY, 
        connections: ["content"] 
      });
    }
    
    currentY += rowHeight;
    
    // Row 4: Elements
    const buttons = (code.match(/<button/gi) || []).length;
    const images = (code.match(/<img/gi) || []).length;
    const inputs = (code.match(/<input/gi) || []).length;
    const links = (code.match(/<a /gi) || []).length;
    
    const row4Nodes: { id: string; name: string; type: "interactive" | "element"; desc: string }[] = [];
    if (buttons > 0) row4Nodes.push({ id: "btns", name: `${buttons} Buttons`, type: "interactive", desc: "Click actions" });
    if (links > 5) row4Nodes.push({ id: "links", name: `${links} Links`, type: "interactive", desc: "Navigation links" });
    if (images > 0) row4Nodes.push({ id: "imgs", name: `${images} Images`, type: "element", desc: "Visual media" });
    if (inputs > 0) row4Nodes.push({ id: "inputs", name: `${inputs} Inputs`, type: "interactive", desc: "Form fields" });
    
    const spacing4 = colWidth;
    const startX4 = centerX - ((row4Nodes.length - 1) * spacing4) / 2;
    const parentNode = row3Nodes.length > 0 ? row3Nodes[0].id : "content";
    for (let i = 0; i < row4Nodes.length; i++) {
      await addNode({ 
        id: row4Nodes[i].id, 
        name: row4Nodes[i].name, 
        type: row4Nodes[i].type, 
        description: row4Nodes[i].desc, 
        x: startX4 + (i * spacing4), 
        y: currentY, 
        connections: [parentNode] 
      });
    }
    
    currentY += rowHeight;
    
    // Row 5: Footer
    if (/<footer/i.test(code)) {
      await addNode({ id: "footer", name: "Footer", type: "component", description: "Page footer & links", x: centerX, y: currentY, connections: ["root"] });
    }
    
    setArchBuilding(false);
  };

  // Build PRODUCT FLOW MAP from ACTUAL code content
  // Analyzes the generated code to detect:
  // - CONFIRMED pages: x-show Alpine.js pages with actual content
  // - POSSIBLE pages: Navigation items without content (marked with comments)
  // - Flow edges: Navigation relationships between pages
  const buildFlowLive = async (code: string) => {
    console.log('[buildFlowLive] Starting flow build, code length:', code.length);
    setFlowBuilding(true);
    setFlowNodes([]);
    setFlowEdges([]);
    
    const addNode = async (node: ProductFlowNode) => {
      await new Promise(r => setTimeout(r, 30));
      setFlowNodes(prev => [...prev, node]);
    };
    
    const addEdge = async (edge: ProductFlowEdge) => {
      await new Promise(r => setTimeout(r, 15));
      setFlowEdges(prev => [...prev, edge]);
    };
    
    // 
    // STEP 1: Detect CONFIRMED pages (Alpine.js x-show with actual content)
    // These are pages that were actually shown in the video
    // 
    
    interface DetectedPage {
      id: string;
      name: string;
      isConfirmed: boolean; // Has actual content (shown in video)
      hasContent: boolean;
      contentPreview?: string;
      isAddedByAI?: boolean; // Was this page added by Edit with AI?
    }
    
    const detectedPages: DetectedPage[] = [];
    const processedIds = new Set<string>();
    
    // Check if code has Alpine.js multi-page structure
    const hasAlpinePages = /x-show\s*=\s*["'](?:currentPage|page|activeTab|activeView)/i.test(code);
    console.log('[buildFlowLive] hasAlpinePages:', hasAlpinePages);
    
    // Pattern 1: Find ALL x-show page identifiers first
    const pageIdentifiers: string[] = [];
    const pageIdRegex = /x-show\s*=\s*["'](?:currentPage|page|activeTab|activeView)\s*===?\s*['"]([^'"]+)['"]/gi;
    let match;
    while ((match = pageIdRegex.exec(code)) !== null) {
      const pageId = match[1];
      if (!pageIdentifiers.includes(pageId)) {
        pageIdentifiers.push(pageId);
      }
    }
    console.log('[buildFlowLive] Found page identifiers:', pageIdentifiers);
    
    // For each page identifier, check if it has real content
    for (const pageId of pageIdentifiers) {
      const normalizedId = pageId.toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if (processedIds.has(normalizedId)) continue;
      processedIds.add(normalizedId);
      
      // Look for the content of this page
      const contentRegex = new RegExp(
        `x-show\\s*=\\s*["'](?:currentPage|page|activeTab|activeView)\\s*===?\\s*['"]${pageId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"][^>]*>([\\s\\S]*?)(?=<(?:main|div|section)[^>]*x-show\\s*=|</body>|$)`,
        'i'
      );
      const contentMatch = code.match(contentRegex);
      const content = contentMatch ? contentMatch[1] : '';
      
      // Check if has real content (not placeholder)
      const hasRealContent = content.length > 100 && 
                            !content.includes('Page not shown in video') &&
                            !content.includes('POSSIBLE:') &&
                            !content.includes('not yet created') &&
                            (/<(?:div|section|article|img|h[1-6]|p|ul|table|form)/i.test(content));
      
      const pageName = pageId
        .replace(/[-_]/g, ' ')
        .replace(/\b\w/g, l => l.toUpperCase());
      
      // Check if this page was added by AI (has our marker comment)
      const aiMarkerRegex = new RegExp(`<!--\\s*=+\\s*${pageId.toUpperCase()}\\s+PAGE\\s*=+\\s*-->`, 'i');
      const isAddedByAI = aiMarkerRegex.test(code);
      
      detectedPages.push({
        id: normalizedId,
        name: pageName,
        isConfirmed: hasRealContent,
        hasContent: hasRealContent,
        contentPreview: content.slice(0, 100),
        isAddedByAI
      });
    }
    
    // Pattern 2: Navigation buttons that set currentPage (to find pages we might have missed)
    const navButtonRegex = /@click\s*=\s*["'](?:currentPage|page|activeTab|activeView)\s*=\s*['"]([^'"]+)['"]/gi;
    while ((match = navButtonRegex.exec(code)) !== null) {
      const pageId = match[1].toLowerCase().replace(/[^a-z0-9]+/g, '-');
      
      if (processedIds.has(pageId)) continue;
      processedIds.add(pageId);
      
      // Check if this page has x-show content
      const hasXShow = new RegExp(`x-show\\s*=\\s*["'][^"']*${match[1]}`, 'i').test(code);
      
      detectedPages.push({
        id: pageId,
        name: match[1].replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        isConfirmed: hasXShow,
        hasContent: hasXShow
      });
    }
    
    // 
    // STEP 2: Detect navigation items from sidebar/header/nav (POSSIBLE paths)
    // 
    
    // Get navigation areas - look for nav, header, aside, sidebar sections
    const navAreaMatches = [
      ...(code.match(/<aside[^>]*>[\s\S]*?<\/aside>/gi) || []),
      ...(code.match(/<nav[^>]*>[\s\S]*?<\/nav>/gi) || []),
      ...(code.match(/<header[^>]*>[\s\S]*?<\/header>/gi) || []),
      ...(code.match(/<footer[^>]*>[\s\S]*?<\/footer>/gi) || []), // Footer often has nav links
      ...(code.match(/<div[^>]*class\s*=\s*["'][^"']*(?:sidebar|menu|navigation|nav-|topbar)[^"']*["'][^>]*>[\s\S]*?<\/div>/gi) || []),
      ...(code.match(/<ul[^>]*class\s*=\s*["'][^"']*(?:nav|menu)[^"']*["'][^>]*>[\s\S]*?<\/ul>/gi) || [])
    ];
    const navAreas = navAreaMatches.join(' ');
    
    // ALSO look in the ENTIRE code for @click navigation buttons
    // This catches Alpine.js navigation buttons anywhere in the page
    const alpineNavRegex = /@click\s*=\s*["'](?:currentPage|page|activeTab|activeView)\s*=\s*['"]([^'"]+)['"]['"]/gi;
    while ((match = alpineNavRegex.exec(code)) !== null) {
      const pageId = match[1].toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if (!processedIds.has(pageId)) {
        processedIds.add(pageId);
        // Check if this page has content
        const hasContent = new RegExp(`x-show\\s*=\\s*["'][^"']*${match[1]}`, 'i').test(code);
        if (!hasContent) {
          detectedPages.push({
            id: pageId,
            name: match[1].replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
            isConfirmed: false,
            hasContent: false
          });
        }
      }
    }
    
    // Extract navigation items (links and buttons) from nav areas
    const navItemPatterns = [
      /<a[^>]*href\s*=\s*["'][^"']*["'][^>]*>([^<]{2,40})<\/a>/gi,
      /<a[^>]*>([^<]{2,40})<\/a>/gi, // Links without href
      /<button[^>]*>([^<]{2,40})<\/button>/gi,
      /<button[^>]*>(?:<[^>]*>)*([^<]{2,40})/gi, // Buttons with nested elements
      /<span[^>]*>([^<]{2,40})<\/span>/gi, // Spans in nav
      /<li[^>]*>(?:<[^>]*>)*([^<]{2,40})/gi, // List items in nav
    ];
    
    for (const pattern of navItemPatterns) {
      pattern.lastIndex = 0;
      while ((match = pattern.exec(navAreas)) !== null) {
        const text = match[1].trim();
        
        // Filter out non-navigation items
        if (
          text.length < 2 ||
          text.length > 35 ||                // Too long = probably content
          /^\d+:\d+/.test(text) ||           // Time format "12:34"
          /^\d+\s*(tys|mln|K|M)/i.test(text) || // View counts
          /[!?]$/.test(text) ||              // Titles with punctuation
          /\.\.\.$/.test(text) ||            // Truncated text
          /^(wicej|more|less|mniej|see all|view all)$/i.test(text) || // Expansion buttons
          /^(poka|show|hide|ukryj|close|submit|send|search)$/i.test(text) || // Action buttons
          /^\d+$/.test(text) ||              // Just numbers
          /^[\s\W]+$/.test(text)             // Only whitespace/symbols
        ) continue;
        
        const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        if (!id || id.length < 2 || processedIds.has(id)) continue;
        processedIds.add(id);
        
        detectedPages.push({
          id,
          name: text,
          isConfirmed: false, // Navigation item without confirmed page
          hasContent: false
        });
      }
    }
    
    // 
    // STEP 3: Check for POSSIBLE comments in code
    // Pattern: <!-- POSSIBLE: Page not shown in video -->
    // 
    
    const possibleCommentRegex = /<!--\s*POSSIBLE:\s*([^-]+)\s*-->/gi;
    while ((match = possibleCommentRegex.exec(code)) !== null) {
      const possiblePage = match[1].trim().toLowerCase().replace(/[^a-z0-9]+/g, '-');
      const existing = detectedPages.find(p => p.id === possiblePage);
      if (existing) {
        existing.isConfirmed = false;
        existing.hasContent = false;
      }
    }
    
    // 
    // STEP 4: Detect structural components for Home page
    // 
    
    const mainComponents: string[] = [];
    
    if (/<header/i.test(code)) mainComponents.push("Header");
    if (/<aside|sidebar/i.test(code)) mainComponents.push("Sidebar");
    if (/<nav/i.test(code)) mainComponents.push("Navigation");
    if (/grid|cards?/i.test(code)) mainComponents.push("Content Grid");
    if (/<main/i.test(code)) mainComponents.push("Main Content");
    if (/<footer/i.test(code)) mainComponents.push("Footer");
    
    if (mainComponents.length === 0) mainComponents.push("Page Content");
    
    // 
    // STEP 5: Build Flow Map with CONFIRMED and POSSIBLE nodes
    // 
    
    const centerX = 400;
    let currentY = 60;
    const rowHeight = 160;
    const colWidth = 200;
    
    // Separate confirmed from possible pages
    let confirmedPages = detectedPages.filter(p => p.isConfirmed);
    const possiblePages = detectedPages.filter(p => !p.isConfirmed);
    
    // If we have generated code but no confirmed pages, the entire page is "Home" - CONFIRMED
    // This happens when there's no Alpine.js multi-page structure
    if (confirmedPages.length === 0 && code.length > 500) {
      confirmedPages = [{
        id: 'home',
        name: 'Home',
        isConfirmed: true,
        hasContent: true,
        isAddedByAI: false
      }];
    }
    
    // Make sure Home is in confirmed if it exists
    const homeInPossible = possiblePages.findIndex(p => p.id === 'home' || p.id === 'glowna' || p.id === 'main');
    if (homeInPossible >= 0) {
      const homePage = possiblePages.splice(homeInPossible, 1)[0];
      homePage.isConfirmed = true;
      homePage.hasContent = true;
      confirmedPages.unshift(homePage);
    }
    
    // Entry node (Home or first confirmed page)
    const entryPage = confirmedPages[0] || { id: 'home', name: 'Home', isConfirmed: true, hasContent: true, isAddedByAI: false };
    
    await addNode({
      id: entryPage.id,
      name: entryPage.name,
      type: "view",
      description: entryPage.isAddedByAI ? "Generated by AI based on site context" : "Shown and confirmed in the video recording",
      x: centerX,
      y: currentY,
      components: mainComponents,
      status: entryPage.isAddedByAI ? "added" : "observed",
      confidence: entryPage.isAddedByAI ? "medium" : "high"
    });
    
    currentY += rowHeight;
    
    // Add CONFIRMED pages (other than entry)
    const otherConfirmed = confirmedPages.filter(p => p.id !== entryPage.id);
    if (otherConfirmed.length > 0) {
      const startX = centerX - ((otherConfirmed.length - 1) * colWidth) / 2;
      
      for (let i = 0; i < otherConfirmed.length; i++) {
        const page = otherConfirmed[i];
        const x = startX + i * colWidth;
        
        await addNode({
          id: page.id,
          name: page.name,
          type: "view",
          description: page.isAddedByAI ? "Generated by AI based on site context" : "Shown and confirmed in the video recording",
          x: x,
          y: currentY,
          components: page.hasContent ? ["Content"] : [],
          status: page.isAddedByAI ? "added" : "observed",
          confidence: page.isAddedByAI ? "medium" : "high"
        });
        
        await addEdge({
          id: `${entryPage.id}-${page.id}`,
          from: entryPage.id,
          to: page.id,
          label: "Navigate",
          type: "navigation"
        });
      }
      
      currentY += rowHeight;
    }
    
    // Add POSSIBLE pages (navigation items not shown in video)
    if (possiblePages.length > 0) {
      const displayItems = possiblePages.slice(0, 12); // Limit for clarity
      // Calculate startX but ensure it's never negative (minimum 50px from left edge)
      const rawStartX = centerX - ((displayItems.length - 1) * (colWidth * 0.85)) / 2;
      const startX = Math.max(50, rawStartX);
      
      for (let i = 0; i < displayItems.length; i++) {
        const page = displayItems[i];
        const x = startX + i * (colWidth * 0.85);
        
        await addNode({
          id: page.id,
          name: page.name,
          type: "view",
          description: "Present in navigation, but not shown in video",
          x: x,
          y: currentY,
          components: [],
          status: "detected",
          confidence: "medium"
        });
        
        await addEdge({
          id: `${entryPage.id}-${page.id}`,
          from: entryPage.id,
          to: page.id,
          label: "Possible",
          type: "possible"
        });
      }
    }
    
    setFlowBuilding(false);
  };

  // Extract style info from code - with actual fonts and colors
  const extractStyleInfo = (code: string): StyleInfo => {
    const colors: { name: string; value: string }[] = [];
    
    // Extract hex colors
    const hexMatches = code.match(/#[0-9A-Fa-f]{6}|#[0-9A-Fa-f]{3}/g) || [];
    // Extract rgb/rgba colors
    const rgbMatches = code.match(/rgba?\([^)]+\)/g) || [];
    
    // Prioritize actual color values, filter out common neutrals at the end
    const allColors = [...hexMatches, ...rgbMatches];
    const neutrals = ['#fff', '#ffffff', '#000', '#000000', '#fff', 'rgba(0', 'rgb(0', 'rgba(255', 'rgb(255'];
    
    const colorFrequency = new Map<string, number>();
    allColors.forEach(c => {
      const normalized = c.toLowerCase();
      colorFrequency.set(normalized, (colorFrequency.get(normalized) || 0) + 1);
    });
    
    // Sort by frequency and filter out pure black/white
    const sortedColors = [...colorFrequency.entries()]
      .sort((a, b) => b[1] - a[1])
      .filter(([c]) => !neutrals.some(n => c.startsWith(n)))
      .slice(0, 4);
    
    // Add back black/white at end if space
    const finalColors = sortedColors.map(([c]) => c);
    if (finalColors.length < 6 && hexMatches.some(c => c.toLowerCase() === '#ffffff' || c.toLowerCase() === '#fff')) {
      finalColors.push('#ffffff');
    }
    if (finalColors.length < 6 && hexMatches.some(c => c.toLowerCase() === '#000000' || c.toLowerCase() === '#000')) {
      finalColors.push('#000000');
    }
    
    finalColors.slice(0, 6).forEach((c, i) => {
      const names = ["Primary", "Secondary", "Accent", "Background", "Text", "Border"];
      colors.push({ name: names[i] || `Color ${i + 1}`, value: c });
    });
    
    // If no colors found, use defaults
    if (colors.length === 0) {
      colors.push({ name: "Primary", value: "#6366f1" });
      colors.push({ name: "Background", value: "#ffffff" });
    }
    
    const fonts: { name: string; usage: string; weight: string; family: string }[] = [];
    
    // Extract actual font families from code
    const fontFamilyMatch = code.match(/font-family:\s*['"]?([^'";,]+)/gi) || [];
    const googleFontsMatch = code.match(/family=([^&:]+)/gi) || [];
    
    const detectedFonts = new Set<string>();
    
    fontFamilyMatch.forEach(f => {
      const name = f.replace(/font-family:\s*['"]?/i, '').trim();
      if (name && !name.includes('sans-serif') && !name.includes('system') && name.length < 30) {
        detectedFonts.add(name);
      }
    });
    
    googleFontsMatch.forEach(f => {
      const name = f.replace(/family=/i, '').replace(/\+/g, ' ').split(':')[0].trim();
      if (name && name.length < 30) detectedFonts.add(name);
    });
    
    // Check for common font names in code
    const commonFonts = ["Inter", "Space Grotesk", "Poppins", "Roboto", "Open Sans", "Montserrat", "Nunito", "Lato", "Raleway", "Playfair Display"];
    commonFonts.forEach(font => {
      if (code.includes(font)) detectedFonts.add(font);
    });
    
    Array.from(detectedFonts).slice(0, 4).forEach((font, i) => {
      fonts.push({ 
        name: font, 
        usage: i === 0 ? "Primary font" : i === 1 ? "Secondary font" : "Accent font",
        weight: "400-700",
        family: `'${font}', sans-serif`
      });
    });
    
    if (fonts.length === 0) {
      fonts.push({ name: "System UI", usage: "Default", weight: "400", family: "system-ui, sans-serif" });
    }
    
    return {
      colors,
      fonts,
      spacing: code.includes("gap-") || code.includes("space-") ? "Tailwind spacing scale" : "Custom spacing",
      borderRadius: code.includes("rounded-xl") || code.includes("rounded-2xl") ? "Large (12-16px)" : code.includes("rounded-lg") ? "Medium (8px)" : "Small (4px)",
      shadows: code.includes("shadow-xl") || code.includes("shadow-2xl") ? "Prominent shadows" : code.includes("shadow") ? "Subtle shadows" : "Minimal shadows"
    };
  };

  // Generate file structure from code based on Structure/Flow nodes
  // Supports both single-file (HTML) and componentized (TSX) modes
  const generateFileStructure = useCallback((code: string, nodes: ProductFlowNode[], mode: CodeMode): FileNode[] => {
    const files: FileNode[] = [];
    
    // Extract Alpine.js pages from the code - IMPROVED detection
    const extractAlpinePages = (): { id: string; name: string; content: string; isConfirmed: boolean }[] => {
      const pages: { id: string; name: string; content: string; isConfirmed: boolean }[] = [];
      const processedIds = new Set<string>();
      
      // First find all page identifiers
      const pageIdRegex = /x-show\s*=\s*["'](?:currentPage|page|activeTab|activeView)\s*===?\s*['"]([^'"]+)['"]/gi;
      const pageIdentifiers: string[] = [];
      let match;
      
      while ((match = pageIdRegex.exec(code)) !== null) {
        if (!pageIdentifiers.includes(match[1])) {
          pageIdentifiers.push(match[1]);
        }
      }
      
      // For each identifier, extract its content
      for (const pageId of pageIdentifiers) {
        const normalizedId = pageId.toLowerCase().replace(/[^a-z0-9]+/g, '-');
        if (processedIds.has(normalizedId)) continue;
        processedIds.add(normalizedId);
        
        // Look for the content - find the element with x-show and get its innerHTML
        const escapedPageId = pageId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const contentRegex = new RegExp(
          `<(?:main|div|section)[^>]*x-show\\s*=\\s*["'](?:currentPage|page|activeTab|activeView)\\s*===?\\s*['"]${escapedPageId}['"][^>]*>([\\s\\S]*?)(?=<(?:main|div|section)[^>]*x-show\\s*=|</body>|$)`,
          'i'
        );
        const contentMatch = code.match(contentRegex);
        const content = contentMatch ? contentMatch[0] : '';
        
        const isConfirmed = content.length > 100 && 
                           !content.includes('POSSIBLE:') && 
                           !content.includes('Page not shown in video') &&
                           !content.includes('not yet created');
        
        pages.push({
          id: normalizedId,
          name: pageId.replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          content: content,
          isConfirmed
        });
      }
      
      return pages;
    };
    
    const detectedPages = extractAlpinePages();
    const confirmedPages = detectedPages.filter(p => p.isConfirmed);
    
    if (mode === "single-file") {
      // Single-file mode: main HTML file with all pages in one file
      files.push({
        path: "/pages/index.html",
        name: "index.html",
        content: code,
        type: "page",
        language: "html",
        sourceNodeId: "home",
        lineCount: code.split('\n').length
      });
      
      // Show confirmed pages as indicators in file tree (but they're in main file)
      confirmedPages.forEach(page => {
        if (page.id !== 'home' && page.id !== 'glowna' && page.id !== 'main') {
          files.push({
            path: `/pages/${page.id}.html`,
            name: `${page.id}.html`,
            content: `<!-- This page is embedded in index.html as Alpine.js view: ${page.name} -->
<!-- To view, look for: x-show="currentPage === '${page.id}'" in index.html -->
${page.content}`,
            type: "page",
            language: "html",
            sourceNodeId: page.id,
            lineCount: page.content.split('\n').length
          });
        }
      });
      
      // Only add stub files for detected/possible pages (not observed yet)
      nodes.filter(n => (n.status === "detected" || n.status === "possible") && n.type === "view").forEach(node => {
        // Don't add stub if we already have this page
        if (files.some(f => f.sourceNodeId === node.id)) return;
        
        const stubContent = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${node.name}</title>
</head>
<body>
  <!-- POSSIBLE: This page was in navigation but not shown in video -->
  <div class="min-h-screen bg-gray-900 text-white flex items-center justify-center">
    <div class="text-center">
      <h1 class="text-3xl font-bold mb-4">${node.name}</h1>
      <p class="text-gray-400">Page not yet created. Click "Create" to generate this page.</p>
    </div>
  </div>
</body>
</html>`;
        files.push({
          path: `/pages/${node.id}.html`,
          name: `${node.id}.html`,
          content: stubContent,
          type: "stub",
          language: "html",
          sourceNodeId: node.id,
          isStub: true,
          lineCount: stubContent.split('\n').length
        });
      });
    } else {
      // Componentized mode: split into REAL components extracted from HTML
      const homeNode = nodes.find(n => n.id === "home");
      const components = homeNode?.components || [];
      const componentFiles: FileNode[] = [];
      
      // Also detect all Alpine.js pages in the code
      const alpinePageRegex = /x-show="(?:currentPage|page|activeTab)\s*===?\s*['\"]([^'\"]+)['\"]"[^>]*>([\s\S]*?)(?=<(?:main|div|section)[^>]*x-show|<\/body>)/gi;
      const detectedAlpinePages: { id: string; name: string; content: string }[] = [];
      let alpineMatch;
      while ((alpineMatch = alpinePageRegex.exec(code)) !== null) {
        const pageId = alpineMatch[1].toLowerCase().replace(/[^a-z0-9]+/g, '-');
        const pageName = alpineMatch[1].replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const content = alpineMatch[0];
        if (content.length > 200 && !content.includes('POSSIBLE:')) {
          detectedAlpinePages.push({ id: pageId, name: pageName, content });
        }
      }
      
      // Better extraction patterns for actual HTML sections
      const extractComponent = (compName: string): string => {
        const compId = compName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
        const compNameClean = compName.toLowerCase();
        
        let extracted = '';
        
        // 1. Try to find semantic HTML elements directly
        if (compNameClean.includes('navigation') || compNameClean.includes('nav') || compNameClean.includes('sidebar')) {
          // Try nav first, then aside (sidebar)
          const navMatch = code.match(/<nav[^>]*>[\s\S]*?<\/nav>/i);
          const asideMatch = code.match(/<aside[^>]*>[\s\S]*?<\/aside>/i);
          extracted = navMatch?.[0] || asideMatch?.[0] || '';
        } else if (compNameClean.includes('header')) {
          const headerMatch = code.match(/<header[^>]*>[\s\S]*?<\/header>/i);
          extracted = headerMatch?.[0] || '';
        } else if (compNameClean.includes('footer')) {
          const footerMatch = code.match(/<footer[^>]*>[\s\S]*?<\/footer>/i);
          extracted = footerMatch?.[0] || '';
        } else if (compNameClean.includes('hero')) {
          // Hero is usually first section or div with hero class
          const heroMatch = code.match(/<section[^>]*class="[^"]*hero[^"]*"[^>]*>[\s\S]*?<\/section>/i) ||
                          code.match(/<div[^>]*class="[^"]*hero[^"]*"[^>]*>[\s\S]*?<\/div>/i) ||
                          code.match(/<section[^>]*>[\s\S]*?<\/section>/i); // First section as fallback
          extracted = heroMatch?.[0] || '';
        } else if (compNameClean.includes('main') || compNameClean.includes('content')) {
          const mainMatch = code.match(/<main[^>]*>[\s\S]*?<\/main>/i);
          extracted = mainMatch?.[0] || '';
        } else if (compNameClean.includes('grid') || compNameClean.includes('card')) {
          // Look for grid/card containers
          const gridMatch = code.match(/<div[^>]*class="[^"]*(?:grid|cards)[^"]*"[^>]*>[\s\S]*?<\/div>/i);
          extracted = gridMatch?.[0] || '';
        } else if (compNameClean.includes('section')) {
          // Get all sections
          const sectionMatches = code.match(/<section[^>]*>[\s\S]*?<\/section>/gi) || [];
          extracted = sectionMatches.join('\n\n');
        } else {
          // 2. Try to find element with matching ID or class
          const patterns = [
            new RegExp(`<section[^>]*id="[^"]*${compId}[^"]*"[^>]*>[\\s\\S]*?</section>`, 'i'),
            new RegExp(`<section[^>]*class="[^"]*${compId}[^"]*"[^>]*>[\\s\\S]*?</section>`, 'i'),
            new RegExp(`<div[^>]*id="[^"]*${compId}[^"]*"[^>]*>[\\s\\S]*?</div>`, 'i'),
            new RegExp(`<div[^>]*class="[^"]*${compId}[^"]*"[^>]*>[\\s\\S]*?</div>`, 'i'),
          ];
          
          for (const pattern of patterns) {
            const match = code.match(pattern);
            if (match) {
              extracted = match[0];
              break;
            }
          }
          
          // 3. Try to find a section that contains a heading with this name
          if (!extracted) {
            const sectionRegex = /<section[^>]*>([\s\S]*?)<\/section>/gi;
            let match;
            while ((match = sectionRegex.exec(code)) !== null) {
              const sectionContent = match[0];
              // Check if section contains heading with component name (case insensitive)
              const nameWords = compName.split(/\s+/).filter(w => w.length > 2);
              const hasMatch = nameWords.some(word => 
                new RegExp(`<h[1-3][^>]*>[^<]*${word}[^<]*</h[1-3]>`, 'i').test(sectionContent)
              );
              if (hasMatch) {
                extracted = sectionContent;
                break;
              }
            }
          }
        }
        
        // If still nothing, return a meaningful placeholder
        if (!extracted) {
          return `<!-- ${compName}: Component content not found in generated HTML -->
<div class="${compId}">
  <!-- This component could not be automatically extracted -->
  <!-- The original HTML may not have a distinct section for "${compName}" -->
</div>`;
        }
        
        return extracted;
      };
      
      // Extract each component
      components.forEach((compName) => {
        const compId = compName.toLowerCase().replace(/\s+/g, '-');
        const componentContent = extractComponent(compName);
        
        const folder = compName.toLowerCase().includes('header') || 
                      compName.toLowerCase().includes('footer') || 
                      compName.toLowerCase().includes('navigation') ||
                      compName.toLowerCase().includes('nav')
          ? 'layout' 
          : 'sections';
        
        const reactComponent = wrapAsReactComponent(compName, componentContent);
        
        componentFiles.push({
          path: `/components/${folder}/${compId}.tsx`,
          name: `${compId}.tsx`,
          content: reactComponent,
          type: "component",
          language: "tsx",
          sourceNodeId: "home",
          lineCount: reactComponent.split('\n').length
        });
      });
      
      // Main page file that imports components
      const mainPageContent = generateMainPageFile(components);
      files.push({
        path: "/pages/index.tsx",
        name: "index.tsx",
        content: mainPageContent,
        type: "page",
        language: "tsx",
        sourceNodeId: "home",
        lineCount: mainPageContent.split('\n').length
      });
      
      // Add page files for all detected Alpine.js pages
      detectedAlpinePages.forEach(page => {
        // Skip home/main/index as we already have that
        if (page.id === 'home' || page.id === 'glowna' || page.id === 'main') return;
        
        const pageComponent = wrapAsReactComponent(page.name, page.content);
        files.push({
          path: `/pages/${page.id}.tsx`,
          name: `${page.id}.tsx`,
          content: pageComponent,
          type: "page",
          language: "tsx",
          sourceNodeId: page.id,
          lineCount: pageComponent.split('\n').length
        });
      });
      
      // Also add pages from flow nodes that are observed
      nodes.filter(n => n.status === "observed" && n.id !== "home" && n.type === "view")
        .forEach(node => {
          // Skip if we already have this page
          if (files.some(f => f.sourceNodeId === node.id)) return;
          
          // Try to extract content for this page from the code
          const pageContentRegex = new RegExp(`x-show="[^"]*${node.id}[^"]*"[^>]*>([\\s\\S]*?)(?=<(?:main|div|section)[^>]*x-show|<\\/body>)`, 'i');
          const contentMatch = code.match(pageContentRegex);
          const content = contentMatch ? contentMatch[0] : `<div class="p-8"><h1>${node.name}</h1></div>`;
          
          const pageComponent = wrapAsReactComponent(node.name, content);
          files.push({
            path: `/pages/${node.id}.tsx`,
            name: `${node.id}.tsx`,
            content: pageComponent,
            type: "page",
            language: "tsx",
            sourceNodeId: node.id,
            lineCount: pageComponent.split('\n').length
          });
        });
      
      files.push(...componentFiles);
      
      // Add tokens file
      const tokensContent = generateTokensFile(extractStyleInfo(code));
      files.push({
        path: "/styles/tokens.ts",
        name: "tokens.ts",
        content: tokensContent,
        type: "style",
        language: "ts",
        lineCount: tokensContent.split('\n').length
      });
    }
    
    return files;
  }, []);
  
  // Helper: Wrap HTML content as React component
  const wrapAsReactComponent = (name: string, htmlContent: string): string => {
    const componentName = name.replace(/[^a-zA-Z0-9]/g, '');
    
    // Clean up the HTML content for embedding
    const cleanedHtml = htmlContent
      .replace(/`/g, '\\`')
      .replace(/\${/g, '\\${')
      .trim();
    
    // If content is just a comment (not extracted), create a placeholder
    if (cleanedHtml.startsWith('<!--') && cleanedHtml.length < 100) {
      return `import React from 'react';

interface ${componentName}Props {
  className?: string;
}

export default function ${componentName}({ className }: ${componentName}Props) {
  return (
    <section className={\`\${className || ''} py-16\`}>
      <div className="container mx-auto px-4">
        <h2 className="text-3xl font-bold mb-8">${name}</h2>
        {/* TODO: Add ${name} content */}
      </div>
    </section>
  );
}`;
    }
    
    return `import React from 'react';

interface ${componentName}Props {
  className?: string;
}

export default function ${componentName}({ className }: ${componentName}Props) {
  return (
    <div className={className} dangerouslySetInnerHTML={{ __html: \`
${cleanedHtml}
    \` }} />
  );
}`;
  };
  
  // Helper: Generate main page file with imports
  const generateMainPageFile = (components: string[]): string => {
    const imports = components.map(comp => {
      const compName = comp.replace(/\s+/g, '');
      const compId = comp.toLowerCase().replace(/\s+/g, '-');
      const folder = comp.toLowerCase().includes('header') || comp.toLowerCase().includes('footer') || comp.toLowerCase().includes('navigation') 
        ? 'layout' 
        : 'sections';
      return `import ${compName} from '@/components/${folder}/${compId}';`;
    }).join('\n');
    
    const componentUsage = components.map(comp => {
      const compName = comp.replace(/\s+/g, '');
      return `      <${compName} />`;
    }).join('\n');
    
    return `import React from 'react';
${imports}

export default function HomePage() {
  return (
    <main className="min-h-screen">
${componentUsage}
    </main>
  );
}`;
  };
  
  // Helper: Generate tokens file from style info
  const generateTokensFile = (style: StyleInfo): string => {
    const colorTokens = style.colors.map(c => `  '${c.name.toLowerCase()}': '${c.value}',`).join('\n');
    const fontTokens = style.fonts.map(f => `  '${f.name.toLowerCase().replace(/\s+/g, '-')}': '${f.family}',`).join('\n');
    
    return `// Design System Tokens
// Generated from video analysis

export const colors = {
${colorTokens}
};

export const fonts = {
${fontTokens}
};

export const spacing = {
  xs: '0.25rem',
  sm: '0.5rem',
  md: '1rem',
  lg: '1.5rem',
  xl: '2rem',
  '2xl': '3rem',
};

export const borderRadius = {
  sm: '0.25rem',
  md: '0.5rem',
  lg: '0.75rem',
  xl: '1rem',
  full: '9999px',
};

export const shadows = {
  sm: '0 1px 2px rgba(0, 0, 0, 0.05)',
  md: '0 4px 6px rgba(0, 0, 0, 0.1)',
  lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
  xl: '0 20px 25px rgba(0, 0, 0, 0.15)',
};
`;
  };
  
  // Build file tree structure from files
  const buildFileTree = useCallback((files: FileNode[]): (FileTreeFolder | FileTreeFile)[] => {
    const root: Map<string, FileTreeFolder | FileTreeFile> = new Map();
    const folders: Map<string, FileTreeFolder> = new Map();
    
    // Create folders
    files.forEach(file => {
      const parts = file.path.split('/').filter(Boolean);
      let currentPath = '';
      
      parts.slice(0, -1).forEach(part => {
        const parentPath = currentPath;
        currentPath = currentPath ? `${currentPath}/${part}` : `/${part}`;
        
        if (!folders.has(currentPath)) {
          const folder: FileTreeFolder = {
            name: part,
            path: currentPath,
            type: "folder",
            children: [],
            expanded: expandedFolders.has(currentPath)
          };
          folders.set(currentPath, folder);
          
          if (parentPath) {
            const parent = folders.get(parentPath);
            if (parent) {
              parent.children.push(folder);
            }
          }
        }
      });
    });
    
    // Add files to their folders
    files.forEach(file => {
      const parts = file.path.split('/').filter(Boolean);
      const folderPath = '/' + parts.slice(0, -1).join('/');
      const folder = folders.get(folderPath);
      
      const fileNode: FileTreeFile = {
        name: file.name,
        path: file.path,
        type: "file",
        fileType: file.type,
        isStub: file.isStub,
        sourceNodeId: file.sourceNodeId
      };
      
      if (folder) {
        folder.children.push(fileNode);
      }
    });
    
    // Get root level folders
    const rootFolders: (FileTreeFolder | FileTreeFile)[] = [];
    folders.forEach((folder, path) => {
      if (path.split('/').filter(Boolean).length === 1) {
        rootFolders.push(folder);
      }
    });
    
    return rootFolders.sort((a, b) => {
      const order = { pages: 1, components: 2, styles: 3, types: 4 };
      return (order[a.name as keyof typeof order] || 99) - (order[b.name as keyof typeof order] || 99);
    });
  }, [expandedFolders]);
  
  // Get active file content
  const getActiveFileContent = useCallback((): string => {
    // First, try to find the file in generatedFiles
    const file = generatedFiles.find(f => f.path === activeFilePath);
    if (file && file.content) return file.content;
    
    // Fallback to displayedCode for the main HTML file
    if (activeFilePath === "/pages/index.html" || activeFilePath === "/pages/index.tsx") {
      return displayedCode;
    }
    
    return displayedCode;
  }, [generatedFiles, activeFilePath, displayedCode]);
  
  // Handle node click from Flow - focus on corresponding code
  const handleFlowNodeCodeFocus = useCallback((nodeId: string) => {
    setViewMode("code");
    
    // Find file for this node
    const file = generatedFiles.find(f => f.sourceNodeId === nodeId);
    if (file) {
      setActiveFilePath(file.path);
      
      // Find reference map entry
      const ref = codeReferenceMap.find(r => r.nodeId === nodeId);
      if (ref) {
        setHighlightedLines({ start: ref.startLine, end: ref.endLine });
        // Clear highlight after 3 seconds
        setTimeout(() => setHighlightedLines(null), 3000);
      }
    } else if (nodeId !== "home") {
      // Node is possible but not built - set up AI edit
      // Only if not currently editing
      if (isEditing) return;
      const node = flowNodes.find(n => n.id === nodeId);
      if (node) {
        setEditInput(`@${node.name} Create this page with full content and layout`);
        setShowFloatingEdit(true);
      }
    }
  }, [generatedFiles, codeReferenceMap, flowNodes]);
  
  // Toggle folder expansion
  const toggleFolder = useCallback((path: string) => {
    setExpandedFolders(prev => {
      const next = new Set(prev);
      if (next.has(path)) {
        next.delete(path);
      } else {
        next.add(path);
      }
      return next;
    });
  }, []);
  
  // Generate a suggested flow node extension - directly adds to flow and triggers AI
  const suggestFlowExtension = (fromNode: ProductFlowNode, actionType: string) => {
    // Block if currently editing
    if (isEditing) {
      showToast("Wait for current generation to finish", "info");
      return;
    }
    console.log('[suggestFlowExtension] Called with:', fromNode.name, actionType);
    
    // Generate context-aware names and prompts based on action type
    let nodeName = '';
    let nodeDescription = '';
    let edgeLabel = '';
    let aiPrompt = '';
    
    // Make unique names with timestamp
    const timestamp = Date.now();
    const existingNodeNames = flowNodes.map(n => n.name.toLowerCase());
    
    switch (actionType) {
      case 'extend':
        nodeName = `${fromNode.name}-detail`;
        nodeDescription = `Detail view for ${fromNode.name}`;
        edgeLabel = 'opens';
        aiPrompt = `@${nodeName} Create a detail page for ${fromNode.name}. Show expanded information, more details, and actions related to ${fromNode.name}. Include a back button to return. Match the existing design.`;
        break;
      case 'alternative':
        nodeName = `${fromNode.name}-v2`;
        nodeDescription = `Alternative version of ${fromNode.name}`;
        edgeLabel = 'alternative';
        aiPrompt = `@${nodeName} Create an alternative version of the ${fromNode.name} page. Keep the same purpose but use a different layout, different visual hierarchy, or different interaction pattern. Include same navigation as original.`;
        break;
      case 'subflow':
        nodeName = `${fromNode.name}-items`;
        nodeDescription = `Items/list within ${fromNode.name}`;
        edgeLabel = 'contains';
        aiPrompt = `@${nodeName} Create a list/items view within ${fromNode.name}. Show a collection of items with filtering, search, or categorization. Each item should be clickable. Match the existing design patterns.`;
        break;
      default:
        nodeName = `${fromNode.name}-next`;
        nodeDescription = `Next step from ${fromNode.name}`;
        edgeLabel = 'leads to';
        aiPrompt = `@${nodeName} Create a logical next page after ${fromNode.name}. Think about what action a user would take on ${fromNode.name} and create the resulting page.`;
    }
    
    // Make name unique if already exists
    let finalName = nodeName;
    let counter = 1;
    while (existingNodeNames.includes(finalName.toLowerCase())) {
      finalName = `${nodeName}-${counter}`;
      counter++;
    }
    nodeName = finalName;
    aiPrompt = aiPrompt.replace(/@[a-zA-Z0-9-_]+/, `@${nodeName}`);
    
    const nodeId = `node_${timestamp}`;
    
    // Position below/beside source node
    const newNode: ProductFlowNode = {
      id: nodeId,
      name: nodeName,
      type: 'view',
      description: nodeDescription,
      x: actionType === 'alternative' ? fromNode.x + 200 : fromNode.x + 50,
      y: actionType === 'alternative' ? fromNode.y : fromNode.y + 150,
      status: 'added',
      confidence: 'medium',
    };
    
    const newEdge: ProductFlowEdge = {
      id: `edge_${fromNode.id}_${nodeId}`,
      from: fromNode.id,
      to: nodeId,
      label: edgeLabel,
      type: 'navigation',
    };
    
    console.log('[suggestFlowExtension] Adding node:', newNode);
    console.log('[suggestFlowExtension] Adding edge:', newEdge);
    
    // Directly add the node and edge
    setFlowNodes(prev => [...prev, newNode]);
    setFlowEdges(prev => [...prev, newEdge]);
    
    // Close the node detail panel
    setSelectedFlowNode(null);
    
    // Open AI edit panel with context-aware prompt and auto-trigger
    setEditInput(aiPrompt);
    setShowFloatingEdit(true);
    
    // Auto-trigger AI generation
    setTimeout(() => {
      const sendBtn = document.querySelector('[data-edit-send-btn]') as HTMLButtonElement;
      if (sendBtn && !sendBtn.disabled) {
        sendBtn.click();
        showToast(`Generating ${nodeName}...`, 'info');
      }
    }, 150);
  };
  

  useEffect(() => {
    if (generatedCode && !isStreamingCode) {
      buildArchitectureLive(generatedCode);
      buildFlowLive(generatedCode);
      setStyleInfo(extractStyleInfo(generatedCode));
    }
  }, [generatedCode, isStreamingCode]);
  
  // Generate file structure when code or flow nodes change
  useEffect(() => {
    if (generatedCode && !isStreamingCode) {
      const files = generateFileStructure(generatedCode, flowNodes, codeMode);
      setGeneratedFiles(files);
      
      // Set default active file based on mode
      const newPath = codeMode === "single-file" ? "/pages/index.html" : "/pages/index.tsx";
      setActiveFilePath(newPath);
    }
  }, [generatedCode, isStreamingCode, flowNodes, codeMode, generateFileStructure]);
  
  // When activeFilePath changes, update editableCode to match the file content
  useEffect(() => {
    if (generatedFiles.length > 0 && activeFilePath) {
      const file = generatedFiles.find(f => f.path === activeFilePath);
      if (file && file.content) {
        setEditableCode(file.content);
      }
    }
  }, [activeFilePath, generatedFiles]);

  const getSupportedMimeType = () => {
    const types = ["video/webm;codecs=vp8,opus", "video/webm;codecs=vp8", "video/webm", "video/mp4"];
    for (const type of types) {
      if (MediaRecorder.isTypeSupported(type)) return type;
    }
    return "video/webm";
  };

  // Check if mobile device (function version for runtime checks)
  const checkIsMobile = () => {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           (window.innerWidth <= 768);
  };

  const [showMobileRecordingInfo, setShowMobileRecordingInfo] = useState(false);

  const startRecording = async () => {
    // Check for mobile - show custom modal
    if (checkIsMobile()) {
      setShowMobileRecordingInfo(true);
      return;
    }

    try {
      const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
      streamRef.current = screenStream;
      chunksRef.current = [];
      const mimeType = getSupportedMimeType();
      const mediaRecorder = new MediaRecorder(screenStream, { mimeType });
      
      mediaRecorder.ondataavailable = (e) => { 
        console.log("Data chunk received:", e.data.size);
        if (e.data.size > 0) chunksRef.current.push(e.data); 
      };
      
      let hasProcessedStop = false;
      
      mediaRecorder.onstop = async () => {
        // Guard against multiple calls
        if (hasProcessedStop) {
          console.log("onstop already processed, skipping");
          return;
        }
        hasProcessedStop = true;
        
        console.log("=== MediaRecorder.onstop fired ===");
        
        // Clear timer
        if (timerRef.current) {
          clearInterval(timerRef.current);
          timerRef.current = null;
        }
        
        // Stop all tracks
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }
        
        // Create blob and add to flows - copy chunks immediately
        const chunks = [...chunksRef.current];
        chunksRef.current = []; // Clear immediately to prevent reuse
        
        console.log("Chunks collected:", chunks.length);
        
        if (chunks.length > 0) {
          const blob = new Blob(chunks, { type: mimeType });
          console.log("Created blob, size:", blob.size, "bytes");
          
          try {
            await addVideoToFlows(blob, "");
            console.log("Flow added successfully");
          } catch (e) {
            console.error("Error adding flow:", e);
          }
        } else {
          console.log("WARNING: No chunks available!");
        }
        
        // Update state after flow is added
        setIsRecording(false);
        setRecordingDuration(0);
        setViewMode("input");
        mediaRecorderRef.current = null;
        
        console.log("=== Recording cleanup complete ===");
      };
      
      // Handle when user clicks "Stop sharing" in browser UI
      const videoTrack = screenStream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.onended = () => {
          console.log("Screen sharing stopped by user (track ended)");
          if (mediaRecorderRef.current && mediaRecorderRef.current.state === "recording") {
            mediaRecorderRef.current.stop();
          }
        };
      }
      
      mediaRecorderRef.current = mediaRecorder;
      mediaRecorder.start(1000); // Collect data every second
      setIsRecording(true);
      timerRef.current = setInterval(() => setRecordingDuration(prev => prev + 1), 1000);
      console.log("Recording started");
    } catch (err) {
      console.error("Recording error:", err);
      setIsRecording(false);
    }
  };

  const stopRecording = () => {
    console.log("stopRecording called, state:", mediaRecorderRef.current?.state);
    
    // Request final data chunk before stopping
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === "recording") {
      mediaRecorderRef.current.requestData(); // Get any pending data
      mediaRecorderRef.current.stop();
    }
    
    // Clear timer (onstop will also do this, but just in case)
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  };

  const addVideoToFlows = async (blob: Blob, name: string) => {
    console.log("addVideoToFlows called, blob size:", blob.size, "type:", blob.type);
    
    // Validate blob
    if (!blob || blob.size === 0) {
      console.error("Invalid blob - empty or null");
      showToast("Invalid video file", "error");
      return;
    }
    
    const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const url = URL.createObjectURL(blob);
    const video = document.createElement("video");
    video.src = url;
    video.muted = true;
    video.playsInline = true;
    video.preload = "metadata";
    video.setAttribute("webkit-playsinline", "true");
    
    // Don't set crossOrigin for local blob URLs - it can cause issues on mobile
    // video.crossOrigin = "anonymous";
    
    return new Promise<void>((resolve) => {
      let resolved = false;
      
      const generateThumbnail = (videoEl: HTMLVideoElement): string | undefined => {
        try {
          const canvas = document.createElement("canvas");
          const vw = videoEl.videoWidth || 320;
          const vh = videoEl.videoHeight || 180;
          canvas.width = 160;
          canvas.height = Math.round((160 / vw) * vh) || 90;
          const ctx = canvas.getContext("2d");
          if (ctx && vw > 0 && vh > 0) {
            ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL("image/jpeg", 0.8);
            if (dataUrl.length > 1000) return dataUrl;
          }
        } catch (e) {
          console.error("Thumbnail error:", e);
        }
        return undefined;
      };
      
      // Get valid duration - handle Infinity for webm
      const getValidDuration = (): number => {
        const d = video.duration;
        if (d && isFinite(d) && !isNaN(d) && d > 0 && d < 7200) {
          return Math.round(d);
        }
        if (recordingDuration > 0) return recordingDuration;
        // Estimate from blob size (rough average ~800KB/s)
        const est = Math.max(5, Math.round(blob.size / 800000));
        console.log("Estimated duration from blob size:", est);
        return Math.min(est, 300);
      };
      
      const finishCreation = async (thumbnail?: string) => {
        if (resolved) return;
        resolved = true;
        
        const duration = getValidDuration();
        const flowId = generateId();
        
        // Generate name - use file name if provided, otherwise create unique recording name
        let baseName = name && name.trim() ? name.trim() : "";
        
        // For mobile, upload to Supabase immediately for persistence
        let permanentUrl = url;
        if (isMobile && user) {
          try {
            // Get upload URL
            const uploadRes = await fetch("/api/upload-video/get-url", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ 
                fileName: `${flowId}.${blob.type.includes("mp4") ? "mp4" : "webm"}`,
                contentType: blob.type || "video/mp4"
              }),
            });
            
            if (uploadRes.ok) {
              const { uploadUrl, publicUrl } = await uploadRes.json();
              
              // Upload video
              const upload = await fetch(uploadUrl, {
                method: "PUT",
                headers: { "Content-Type": blob.type || "video/mp4" },
                body: blob,
              });
              
              if (upload.ok) {
                permanentUrl = publicUrl;
                console.log("Video uploaded to Supabase for persistence:", publicUrl);
              }
            }
          } catch (e) {
            console.error("Background upload failed:", e);
            // Continue with blob URL - video won't persist after refresh
          }
        }
        
        setFlows(prev => {
          // If no name provided, generate based on count
          if (!baseName) {
            baseName = `Recording ${prev.length + 1}`;
          }
          
          // Ensure unique name by checking existing flows
          const existingNames = prev.map(f => f.name);
          let finalName = baseName;
          let counter = 1;
          while (existingNames.includes(finalName)) {
            counter++;
            finalName = `${baseName} (${counter})`;
          }
          
          const newFlow: FlowItem = {
            id: flowId, 
            name: finalName, 
            videoBlob: blob, 
            videoUrl: permanentUrl, 
            thumbnail: thumbnail || "",
            duration, 
            trimStart: 0, 
            trimEnd: duration,
          };
          console.log("Flow added:", newFlow.name, "duration:", duration, "blob size:", blob.size, "url:", permanentUrl.substring(0, 50));
          return [...prev, newFlow];
        });
        setSelectedFlowId(flowId);
        showToast("Video added", "success");
        resolve();
      };
      
      // Mobile: Use aggressive fast path - don't wait for all events
      if (isMobile) {
        console.log("Mobile device - using fast path");
        // Just wait a short moment for any metadata we can get, then finish
        setTimeout(() => {
          if (!resolved) {
            finishCreation(generateThumbnail(video));
          }
        }, 1500); // 1.5 seconds max wait on mobile
      }
      
      // Handle metadata when loaded
      video.onloadedmetadata = () => {
        console.log("Metadata loaded, raw duration:", video.duration);
        if (isMobile) {
          // On mobile, finish as soon as we have metadata
          setTimeout(() => finishCreation(generateThumbnail(video)), 200);
        } else if (!isFinite(video.duration) || video.duration <= 0) {
          video.currentTime = 1e10; // Seek far to get real duration for webm
        } else {
          video.currentTime = Math.min(1, video.duration * 0.25);
        }
      };
      
      // Handle canplay
      video.oncanplay = () => {
        if (resolved) return;
        console.log("Video can play");
        setTimeout(() => {
          if (!resolved) {
            finishCreation(generateThumbnail(video));
          }
        }, 300);
      };
      
      // Desktop seeking for webm duration fix
      video.onseeked = () => {
        if (resolved || isMobile) return;
        console.log("Seeked to:", video.currentTime, "duration now:", video.duration);
        if (video.currentTime > 100) {
          video.currentTime = Math.min(1, getValidDuration() * 0.25);
          return;
        }
        requestAnimationFrame(() => {
          setTimeout(() => {
            if (resolved) return;
            finishCreation(generateThumbnail(video));
          }, 100);
        });
      };
      
      video.onerror = (e) => {
        console.error("Video load error:", e);
        // Even on error, add the video with estimated data
        if (!resolved) {
          console.log("Attempting fallback despite error");
          finishCreation();
        }
      };
      
      // Ultimate fallback timeout
      setTimeout(() => {
        if (!resolved) {
          console.log("Final timeout - using estimated data");
          finishCreation(generateThumbnail(video));
        }
      }, isMobile ? 3000 : 8000);
      
      video.load();
      
      // Try to play to trigger loading (helps on some mobile browsers)
      video.play().catch(() => {
        console.log("Autoplay blocked");
      });
    });
  };

  // Import flow from landing hero (upload/record/context/style) without touching tool behavior.
  useEffect(() => {
    if (!pending?.blob) return;

    // Safety: only consume once per pending payload
    const payload = pending;
    (async () => {
      try {
        await addVideoToFlows(payload.blob, payload.name || "Flow");
        if (payload.context) setRefinements(payload.context);
        if (payload.styleDirective) setStyleDirective(payload.styleDirective);
        setViewMode("input");
      } finally {
        clearPending();
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pending?.createdAt]);

  const handleFileInput = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files) {
      for (const file of Array.from(files)) {
        // Accept video files - be more lenient with MIME type checking for mobile
        const isVideo = file.type.startsWith("video/") || 
                        file.name.toLowerCase().match(/\.(mp4|mov|webm|avi|mkv|m4v)$/);
        if (isVideo) {
          const sizeMB = file.size / 1024 / 1024;
          console.log(`Adding video: ${file.name}, size: ${sizeMB.toFixed(1)}MB, type: ${file.type}`);
          
          // Just add the video - no size restrictions on frontend
          // Backend will handle any size issues during processing
          await addVideoToFlows(file, file.name.replace(/\.[^/.]+$/, ""));
        } else {
          showToast("Please select a video file", "error");
        }
      }
    }
    e.target.value = "";
  }, [showToast]);

  const removeFlow = (flowId: string) => {
    setFlows(prev => prev.filter(f => f.id !== flowId));
    if (selectedFlowId === flowId) setSelectedFlowId(flows.length > 1 ? flows.find(f => f.id !== flowId)?.id || null : null);
  };

  // Context image/file upload handler - uploads to Supabase Storage
  const handleContextImageUpload = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files) {
      for (const file of Array.from(files)) {
        const id = `ctx-file-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        
        // First add with loading state (local blob for preview)
        const localUrl = URL.createObjectURL(file);
        setContextImages(prev => [...prev, { id, url: localUrl, name: file.name, uploading: true }]);
        
        // Upload to Supabase
        try {
          const formData = new FormData();
          formData.append("file", file);
          formData.append("userId", user?.id || "anon");
          
          const response = await fetch("/api/upload-image", {
            method: "POST",
            body: formData,
          });
          
          const data = await response.json();
          
          if (data.success && data.url) {
            // Replace local URL with Supabase URL
            URL.revokeObjectURL(localUrl);
            setContextImages(prev => prev.map(img => 
              img.id === id ? { ...img, url: data.url, uploading: false } : img
            ));
            console.log("[Upload] Image uploaded to Supabase:", data.url);
          } else {
            console.error("[Upload] Failed:", data.error);
            showToast("Failed to upload image", "error");
            // Keep local URL as fallback
            setContextImages(prev => prev.map(img => 
              img.id === id ? { ...img, uploading: false } : img
            ));
          }
        } catch (error) {
          console.error("[Upload] Error:", error);
          showToast("Failed to upload image", "error");
          setContextImages(prev => prev.map(img => 
            img.id === id ? { ...img, uploading: false } : img
          ));
        }
      }
    }
    e.target.value = "";
  }, [user, showToast]);

  const removeContextImage = useCallback((id: string) => {
    setContextImages(prev => {
      const img = prev.find(i => i.id === id);
      if (img) URL.revokeObjectURL(img.url);
      return prev.filter(i => i.id !== id);
    });
  }, []);

  // CRUD operations for generations
  const renameGeneration = (id: string, newTitle: string) => {
    const updatedGen = generations.find(g => g.id === id);
    if (updatedGen) {
      const renamedGen = { ...updatedGen, title: newTitle, autoTitle: false };
      setGenerations(prev => prev.map(g => g.id === id ? renamedGen : g));
      if (activeGeneration?.id === id) {
        setActiveGeneration(prev => prev ? { ...prev, title: newTitle, autoTitle: false } : null);
        setGenerationTitle(newTitle);
      }
      // Sync rename to Supabase
      saveGenerationToSupabase(renamedGen);
    }
    setRenamingId(null);
    setRenameValue("");
  };
  
  // Save a version snapshot to the active generation
  const saveVersion = useCallback((label: string) => {
    if (!activeGeneration || !generatedCode) return;
    
    const newVersion: GenerationVersion = {
      id: generateId(),
      timestamp: Date.now(),
      label,
      code: generatedCode,
      flowNodes: [...flowNodes],
      flowEdges: [...flowEdges],
      styleInfo: styleInfo ? { ...styleInfo } : null,
    };
    
    setGenerations(prev => prev.map(gen => {
      if (gen.id === activeGeneration.id) {
        const existingVersions = gen.versions || [];
        // Keep last 20 versions max
        const updatedVersions = [...existingVersions, newVersion].slice(-20);
        return { ...gen, versions: updatedVersions };
      }
      return gen;
    }));
    
    // Also update active generation
    setActiveGeneration(prev => {
      if (!prev) return prev;
      const existingVersions = prev.versions || [];
      const updatedVersions = [...existingVersions, newVersion].slice(-20);
      return { ...prev, versions: updatedVersions };
    });
  }, [activeGeneration, generatedCode, flowNodes, flowEdges, styleInfo]);
  
  // Restore to a specific version
  const restoreVersion = useCallback((genId: string, version: GenerationVersion) => {
    const gen = generations.find(g => g.id === genId);
    if (!gen) return;
    
    // Save current state as a version before restoring
    if (activeGeneration?.id === genId && generatedCode) {
      saveVersion("Before restore");
    }
    
    // Restore the version
    setGeneratedCode(version.code);
    setDisplayedCode(version.code);
    setEditableCode(version.code);
    setFlowNodes(version.flowNodes);
    setFlowEdges(version.flowEdges);
    if (version.styleInfo) setStyleInfo(version.styleInfo);
    
    // Update preview
    const blob = new Blob([version.code], { type: "text/html" });
    setPreviewUrl(URL.createObjectURL(blob));
    
    showToast(`Restored to: ${version.label}`, "success");
    setExpandedVersions(null);
  }, [generations, activeGeneration, generatedCode, saveVersion]);
  
  const duplicateGeneration = (gen: GenerationRecord) => {
    const newGen: GenerationRecord = {
      ...gen,
      id: generateId(),
      title: `${gen.title} (Copy)`,
      timestamp: Date.now(),
      autoTitle: false
    };
    setGenerations(prev => [...prev, newGen]);
    setHistoryMenuOpen(null);
    // Save duplicated generation to Supabase
    saveGenerationToSupabase(newGen);
    showToast("Generation duplicated", "success");
  };
  
  const deleteGeneration = async (id: string) => {
    setGenerations(prev => prev.filter(g => g.id !== id));
    if (activeGeneration?.id === id) {
      setActiveGeneration(null);
      // Reset to empty state
      setGeneratedCode(null);
      setDisplayedCode("");
      setEditableCode("");
      setPreviewUrl(null);
      setFlowNodes([]);
      setFlowEdges([]);
      setStyleInfo(null);
      setGenerationTitle("Untitled Project");
      setGenerationComplete(false);
    }
    setHistoryMenuOpen(null);
    showToast("Generation deleted", "info");
    
    // Sync deletion to Supabase
    if (user) {
      try {
        await fetch(`/api/generations?id=${id}`, { method: "DELETE" });
      } catch (e) {
        console.error("Error deleting from Supabase:", e);
      }
    }
  };

  // Smooth trim handlers with live preview
  const handleTrimDrag = (e: React.MouseEvent, type: "start" | "end") => {
    e.preventDefault();
    e.stopPropagation();
    if (!trimBarRef.current || !selectedFlow) return;
    
    // Capture values at start
    const flowId = selectedFlow.id;
    const duration = selectedFlow.duration;
    
    // Guard against invalid duration
    if (!duration || !isFinite(duration) || duration <= 0) return;
    
    setIsDraggingTrim(type);
    
    const updateTrim = (clientX: number) => {
      if (!trimBarRef.current) return;
      const rect = trimBarRef.current.getBoundingClientRect();
      const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
      const percent = x / rect.width;
      let time = percent * duration;
      
      // Guard against NaN/Infinity
      if (!isFinite(time)) time = 0;
      time = Math.max(0, Math.min(time, duration));
      
      setTrimPreviewTime(time);
      
      // Seek video to show preview - guard against invalid values
      if (videoRef.current && isFinite(time)) {
        videoRef.current.currentTime = time;
      }
      
      setFlows(prev => prev.map(f => {
        if (f.id !== flowId) return f;
        if (type === "start") {
          return { ...f, trimStart: Math.min(time, f.trimEnd - 0.5) };
        }
        return { ...f, trimEnd: Math.max(time, f.trimStart + 0.5) };
      }));
    };
    
    const handleMove = (moveEvent: MouseEvent) => {
      moveEvent.preventDefault();
      requestAnimationFrame(() => updateTrim(moveEvent.clientX));
    };
    
    const handleUp = () => {
      setIsDraggingTrim(null);
      setTrimPreviewTime(null);
      document.removeEventListener("mousemove", handleMove);
      document.removeEventListener("mouseup", handleUp);
    };
    
    document.addEventListener("mousemove", handleMove);
    document.addEventListener("mouseup", handleUp);
  };

  const applyTrim = async () => {
    if (!selectedFlow) return;
    
    const trimDuration = selectedFlow.trimEnd - selectedFlow.trimStart;
    console.log(`Trim applied: ${selectedFlow.trimStart}s - ${selectedFlow.trimEnd}s (${trimDuration}s)`);
    
    // Remove any previous trim info from name and add new one
    // Match patterns like "(0s-30s)" or "(29s-30s)"
    const baseName = selectedFlow.name.replace(/\s*\(\d+s-\d+s\)\s*/g, '').trim();
    const newName = `${baseName} (${Math.round(selectedFlow.trimStart)}s-${Math.round(selectedFlow.trimEnd)}s)`;
    
    setFlows(prev => prev.map(f => 
      f.id === selectedFlow.id 
        ? { ...f, name: newName }
        : f
    ));
  };

  // Canvas pan handlers for architecture
  const handleCanvasMouseDown = (e: React.MouseEvent) => {
    if ((e.target as HTMLElement).closest('.arch-node-card')) return;
    setIsPanning(true);
    panStartRef.current = { x: e.clientX, y: e.clientY, panX: canvasPan.x, panY: canvasPan.y };
  };

  const handleCanvasMouseMove = (e: React.MouseEvent) => {
    if (!isPanning) return;
    const dx = e.clientX - panStartRef.current.x;
    const dy = e.clientY - panStartRef.current.y;
    setCanvasPan({ x: panStartRef.current.panX + dx, y: panStartRef.current.panY + dy });
  };

  const handleCanvasMouseUp = () => {
    setIsPanning(false);
  };

  // Handle suggestion click
  const handleSuggestionClick = (nodeId: string) => {
    const lastAt = editInput.lastIndexOf("@");
    setEditInput(editInput.slice(0, lastAt) + `@${nodeId} `);
    setShowSuggestions(false);
    setSelectedArchNode(nodeId);
    editInputRef.current?.focus();
  };

  const togglePlayPause = () => {
    if (!videoRef.current) return;
    if (isPlaying) videoRef.current.pause();
    else videoRef.current.play();
    setIsPlaying(!isPlaying);
  };

  const typeText = async (text: string, onUpdate: (typed: string) => void, speed = 20) => {
    for (let i = 0; i <= text.length; i++) {
      onUpdate(text.slice(0, i));
      await new Promise(r => setTimeout(r, speed));
    }
  };

  const handleGenerate = async () => {
    if (flows.length === 0) return;
    
    // Auth gate: require login
    if (!user) {
      setPendingAction("generate");
      setShowAuthModal(true);
      return;
    }
    
    // SMART EDIT MODE: If we already have generated code, and context has changed,
    // use AI edit instead of regenerating from scratch
    const hasExistingProject = activeGeneration && generatedCode && generationComplete;
    const contextChanged = refinements.trim() !== (activeGeneration?.refinements || "").trim();
    const styleChanged = styleDirective.trim() !== (activeGeneration?.styleDirective || "").trim();
    
    if (hasExistingProject && (contextChanged || styleChanged) && refinements.trim()) {
      // Use Edit mode - cheaper and preserves existing structure
      const editPrompt = refinements.trim() + (styleChanged ? ` Apply style: ${styleDirective}` : "");
      
      // Credits gate for edit
      if (!canAfford(CREDIT_COSTS.AI_EDIT)) {
        setShowOutOfCreditsModal(true);
        return;
      }
      
      // Spend credits for edit
      try {
        const spendRes = await fetch("/api/credits/spend", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            cost: CREDIT_COSTS.AI_EDIT,
            reason: "ai_edit",
            referenceId: `edit_${Date.now()}`,
          }),
        });
        const spendData = await spendRes.json();
        if (!spendData.success) {
          setShowOutOfCreditsModal(true);
          return;
        }
        refreshCredits();
      } catch (error) {
        console.error("Failed to spend credits:", error);
        return;
      }
      
      setIsEditing(true);
      showToast("Updating project with your changes...", "info");
      
      // Get database context if connected
      let dbContextStr: string | undefined;
      if (activeGeneration) {
        try {
          const dbCtx = await getDatabaseContext(activeGeneration.id);
          if (dbCtx.isConnected) {
            dbContextStr = formatDatabaseContextForPrompt(dbCtx);
          }
        } catch {}
      }
      
      try {
        const result = await editCodeWithAI(generatedCode, editPrompt, undefined, dbContextStr);
        if (result.success && result.code) {
          // Save current state as a version before applying changes
          const versionLabel = `Context update: ${refinements.slice(0, 30)}${refinements.length > 30 ? '...' : ''}`;
          
          const newVersion: GenerationVersion = {
            id: generateId(),
            timestamp: Date.now(),
            label: versionLabel,
            code: result.code,
            flowNodes: [...flowNodes],
            flowEdges: [...flowEdges],
            styleInfo: styleInfo ? { ...styleInfo } : null,
          };
          
          // Update active generation with new refinements
          const updatedGen: GenerationRecord = {
            ...activeGeneration,
            code: result.code,
            refinements: refinements,
            styleDirective: styleDirective,
            versions: [...(activeGeneration.versions || []), newVersion].slice(-20),
          };
          
          setActiveGeneration(updatedGen);
          setGenerations(prev => prev.map(g => 
            g.id === activeGeneration.id ? updatedGen : g
          ));
          saveGenerationToSupabase(updatedGen);
          
          setGeneratedCode(result.code);
          setEditableCode(result.code);
          setDisplayedCode(result.code);
          if (previewUrl) URL.revokeObjectURL(previewUrl);
          setPreviewUrl(URL.createObjectURL(new Blob([result.code], { type: "text/html" })));
          buildArchitectureLive(result.code);
          buildFlowLive(result.code);
          setStyleInfo(extractStyleInfo(result.code));
          
          const files = generateFileStructure(result.code, flowNodes, codeMode);
          setGeneratedFiles(files);
          
          showToast("Project updated successfully!", "success");
        } else {
          showToast(result.error || "Failed to update project", "error");
        }
      } catch (error) {
        console.error("Edit error:", error);
        showToast("Failed to update project", "error");
      } finally {
        setIsEditing(false);
      }
      return;
    }
    
    // Credits gate: check if user can afford
    if (!canAfford(CREDIT_COSTS.VIDEO_GENERATE)) {
      setShowOutOfCreditsModal(true);
      return;
    }
    
    // Spend credits before generation
    try {
      const spendRes = await fetch("/api/credits/spend", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          cost: CREDIT_COSTS.VIDEO_GENERATE,
          reason: "video_generate",
          referenceId: `gen_${Date.now()}`,
        }),
      });
      const spendData = await spendRes.json();
      if (!spendData.success) {
        setShowOutOfCreditsModal(true);
        return;
      }
      // Refresh credits after spending
      refreshCredits();
    } catch (error) {
      console.error("Failed to spend credits:", error);
      return;
    }
    
    setIsProcessing(true);
    setGenerationComplete(false);
    setAnalysisDescription("");
    setGeneratedCode(null);
    setDisplayedCode("");
    setEditableCode("");
    
    // Track generation start time for stuck detection
    generationStartTimeRef.current = Date.now();
    streamingCompleteRef.current = false;
    pendingCodeRef.current = null;
    
    // MOBILE: Request Wake Lock to prevent screen from turning off during generation
    let wakeLock: WakeLockSentinel | null = null;
    const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
    if (isMobile && 'wakeLock' in navigator) {
      try {
        wakeLock = await (navigator as any).wakeLock.request('screen');
        console.log("Wake Lock acquired - screen will stay on during generation");
      } catch (err) {
        console.log("Wake Lock not available:", err);
        // Show warning to user
        showToast("Keep your screen on during generation for best results", "info");
      }
    } else if (isMobile) {
      // Wake Lock not supported - warn user
      showToast("Keep your screen on during generation", "info");
    }
    setPreviewUrl(null);
    setIsCodeEditable(false);
    setArchitecture([]);
    setStyleInfo(null);
    // Reset to single-file mode for new generation
    setCodeMode("single-file");
    setActiveFilePath("/pages/index.html");
    // Mark new generation session - hide old content until new content arrives
    const sessionId = `session_${Date.now()}`;
    setGenerationSessionId(sessionId);
    
    // Initialize live analysis phase - UX Signals will be detected from video
    const initialPhase: AnalysisPhase = {
      palette: [],
      typography: "Scanning...",
      vibe: "Analyzing...",
      layout: "Detecting...",
      container: "Scanning...",
      responsive: "Checking...",
      components: [],
      uxSignals: [],
      structureItems: []
    };
    setAnalysisPhase(initialPhase);
    setAnalysisSection("style");
    
    // Real-time analysis simulation based on actual video content
    // UX Signals and Structure are generated live, not mocked
    const updatePhaseRealTime = async () => {
      // Phase 1: UX SIGNALS (0-3s) - Detect behavioral patterns
      setAnalysisSection("style");
      
      // Simulate detecting attention patterns
      await new Promise(r => setTimeout(r, 600));
      setAnalysisPhase(prev => prev ? { 
        ...prev, 
        uxSignals: [{ type: "attention", label: "Attention density", value: "Scanning..." }]
      } : prev);
      
      await new Promise(r => setTimeout(r, 700));
      setAnalysisPhase(prev => prev ? { 
        ...prev, 
        uxSignals: [
          { type: "attention", label: "Attention density", value: "Analyzing focus areas..." },
          { type: "navigation", label: "Navigation depth", value: "Mapping routes..." }
        ]
      } : prev);
      
      await new Promise(r => setTimeout(r, 800));
      setAnalysisPhase(prev => prev ? { 
        ...prev, 
        uxSignals: [
          { type: "attention", label: "Attention density", value: "High" },
          { type: "navigation", label: "Navigation depth", value: "Shallow" },
          { type: "cta", label: "CTA visibility", value: "Detecting..." }
        ]
      } : prev);
      
      await new Promise(r => setTimeout(r, 600));
      setAnalysisPhase(prev => prev ? { 
        ...prev, 
        uxSignals: [
          { type: "attention", label: "Attention density", value: "High" },
          { type: "navigation", label: "Navigation depth", value: "Shallow" },
          { type: "cta", label: "CTA visibility", value: "Prominent" },
          { type: "mobile", label: "Mobile reachability", value: "Checking..." }
        ]
      } : prev);
      
      // Phase 2: STRUCTURE (3-5s) - Detect components
      await new Promise(r => setTimeout(r, 500));
      setAnalysisSection("layout");
      
      // Add structure items one by one as "detected"
      const structureQueue = ["Navigation", "Hero Section", "Content Area", "Call to Action", "Footer"];
      
      for (let i = 0; i < structureQueue.length; i++) {
        await new Promise(r => setTimeout(r, 400 + Math.random() * 300));
        setAnalysisPhase(prev => {
          if (!prev) return prev;
          const newStructure = [...(prev.structureItems || [])];
          // Set previous item to done
          if (newStructure.length > 0) {
            newStructure[newStructure.length - 1].status = "done";
          }
          // Add new item as generating
          newStructure.push({ name: structureQueue[i], status: "generating" });
          return { ...prev, structureItems: newStructure };
        });
      }
      
      // Phase 3: COMPONENTS (5s+) - Generate code components
      await new Promise(r => setTimeout(r, 600));
      setAnalysisSection("components");
      
      // Finalize UX signals with real values
      setAnalysisPhase(prev => prev ? { 
        ...prev, 
        uxSignals: [
          { type: "attention", label: "Attention density", value: "High" },
          { type: "navigation", label: "Navigation depth", value: "Shallow" },
          { type: "cta", label: "CTA visibility", value: "Prominent" },
          { type: "mobile", label: "Mobile reachability", value: "Good" }
        ],
        responsive: "Mobile-First",
        layout: "Flexbox + Grid",
        container: "Centered layout"
      } : prev);
      
      // Mark all structure items as done
      setAnalysisPhase(prev => prev ? {
        ...prev,
        structureItems: (prev.structureItems || []).map(s => ({ ...s, status: "done" as const }))
      } : prev);
    };
    
    updatePhaseRealTime();
    
    try {
      let flow = flows[0];
      const isMobileDevice = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
      
      // Determine video URL - use existing URL if available, or upload new
      let videoUrl: string = "";
      
      // Check if we already have a valid URL (not a blob URL, not empty)
      const hasValidUrl = flow.videoUrl && 
        flow.videoUrl.startsWith("https://") && 
        !flow.videoUrl.startsWith("blob:");
      
      if (hasValidUrl) {
        // Use existing URL (flow was restored from localStorage or already uploaded)
        videoUrl = flow.videoUrl;
        console.log("Using existing video URL:", videoUrl);
      } else {
        // Need to upload the video blob
        const videoSizeMB = flow.videoBlob.size / 1024 / 1024;
        console.log(`Video size: ${videoSizeMB.toFixed(2)} MB, mobile: ${isMobileDevice}`);
        
        // Check if blob is empty (happens when flow is restored incorrectly)
        if (flow.videoBlob.size === 0) {
          showToast("Video not available. Please re-upload the video.", "error");
          setIsProcessing(false);
          generationStartTimeRef.current = null;
          return;
        }
        
        // Max 50MB
        if (videoSizeMB > 50) {
          showToast("Video too large (max 50MB). Please use a shorter recording.", "error");
          setIsProcessing(false);
          generationStartTimeRef.current = null;
          return;
        }
        
        // MOBILE: Try FFmpeg conversion for problematic formats
        const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
        let blobToUpload = flow.videoBlob;
        
        if (isMobile && !videoUrl && flow.videoBlob.size > 0) {
          const videoType = flow.videoBlob.type.toLowerCase();
          // Check if video needs conversion (MOV, HEVC, etc.)
          const needsConversion = videoType.includes("quicktime") || 
                                  videoType.includes("mov") ||
                                  videoType.includes("hevc") ||
                                  videoType.includes("x-m4v") ||
                                  videoType === "" ||
                                  !videoType.includes("mp4");
          
          if (needsConversion) {
            console.log("Mobile video needs FFmpeg conversion:", videoType);
            showToast("Converting video for compatibility...", "info");
            
            try {
              const { convertToMP4, isFFmpegSupported } = await import("@/lib/ffmpeg-converter");
              
              if (isFFmpegSupported()) {
                const convertedBlob = await Promise.race([
                  convertToMP4(flow.videoBlob, (progress) => {
                    console.log("FFmpeg progress:", progress, "%");
                  }),
                  // 3 minute timeout for conversion
                  new Promise<never>((_, reject) => 
                    setTimeout(() => reject(new Error("Conversion timeout")), 180000)
                  )
                ]);
                
                console.log("FFmpeg conversion success:", convertedBlob.size, "bytes");
                blobToUpload = convertedBlob;
                showToast("Video converted successfully!", "success");
              } else {
                console.log("FFmpeg not supported, using original");
              }
            } catch (ffmpegError) {
              console.error("FFmpeg conversion failed:", ffmpegError);
              // Continue with original blob - might work, might not
              showToast("Conversion failed, trying original format...", "info");
            }
          }
        }
        
        // Upload to Supabase (converted or original blob)
        if (!videoUrl) {
          // Use converted blob type if available, otherwise original
          let videoContentType = blobToUpload.type || flow.videoBlob.type || "video/webm";
          
          // Normalize mobile formats for the upload
          if (videoContentType === "video/quicktime" || videoContentType === "video/x-m4v" || 
              videoContentType === "video/3gpp" || !videoContentType.startsWith("video/")) {
            videoContentType = "video/mp4";
          }
          
          const fileExt = videoContentType.includes("webm") ? "webm" : "mp4";
          const uploadSizeMB = blobToUpload.size / (1024 * 1024);
          console.log(`Uploading video to Supabase: type=${videoContentType}, size=${uploadSizeMB.toFixed(2)}MB`);
          
          // Get signed upload URL
          const urlRes = await fetch("/api/upload-video/get-url", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              filename: `recording-${Date.now()}.${fileExt}`,
              contentType: videoContentType,
            }),
          });
          
          if (!urlRes.ok) {
            const errorData = await urlRes.json().catch(() => ({}));
            console.error("Failed to get upload URL:", errorData);
            showToast(errorData.error || "Failed to prepare upload. Please try again.", "error");
            setIsProcessing(false);
            generationStartTimeRef.current = null;
            return;
          }
          
          const { signedUrl, publicUrl } = await urlRes.json();
          
          // Upload directly to Supabase Storage (use converted blob)
          const uploadRes = await fetch(signedUrl, {
            method: "PUT",
            headers: { "Content-Type": videoContentType },
            body: blobToUpload,
          });
          
          if (!uploadRes.ok) {
            console.error("Direct upload failed:", uploadRes.status, uploadRes.statusText);
            showToast("Failed to upload video. Please try again.", "error");
            setIsProcessing(false);
            generationStartTimeRef.current = null;
            return;
          }
          
          videoUrl = publicUrl;
          console.log("Video uploaded to Supabase:", videoUrl);
          
          // Update flow with permanent URL
          setFlows(prev => prev.map(f => 
            f.id === flow.id ? { ...f, videoUrl: publicUrl } : f
          ));
        }
      }
      
      // Build style directive with refinements and trim info
      let fullStyleDirective = styleDirective || "Modern, clean design with smooth animations";
      
      // Add refinements if provided
      if (refinements.trim()) {
        fullStyleDirective += `. Additional refinements: ${refinements.trim()}`;
      }
      
      // Add trim info if applicable
      const isTrimmed = flow.trimStart > 0 || flow.trimEnd < flow.duration;
      console.log(`Flow: trimStart=${flow.trimStart}, trimEnd=${flow.trimEnd}, duration=${flow.duration}, isTrimmed=${isTrimmed}`);
      
      if (isTrimmed) {
        fullStyleDirective += `. CRITICAL: ONLY analyze video content between timestamps ${flow.trimStart.toFixed(1)}s and ${flow.trimEnd.toFixed(1)}s. Ignore ALL content before ${flow.trimStart.toFixed(1)}s and after ${flow.trimEnd.toFixed(1)}s.`;
      } else {
        // Full video selected - add explicit instruction to watch entire video
        fullStyleDirective += `. This is a ${flow.duration} second video. Watch and analyze the ENTIRE video from 0:00 to ${formatDuration(flow.duration)}. Multiple screens or states may appear - include ALL of them.`;
      }
      
      // Check for Supabase integration
      let databaseContextStr = "";
      try {
        const dbContext = await getDatabaseContext(flow.id);
        if (dbContext.isConnected && dbContext.schemaText) {
          databaseContextStr = formatDatabaseContextForPrompt(dbContext);
          console.log("[Generate] Database context found:", dbContext.tables);
        }
      } catch (err) {
        console.log("[Generate] No database context:", err);
      }
      
      const result = await transmuteVideoToCode({
        videoUrl,
        styleDirective: fullStyleDirective,
        databaseContext: databaseContextStr || undefined,
      });
      
      console.log("Generation result:", result);
      
      if (result && result.success && result.code) {
        // Track analytics
        updateProjectAnalytics(flow.id, "generation", result.tokenUsage?.totalTokens);
        
        // Set code and preview URL
        setGeneratedCode(result.code);
        const blob = new Blob([result.code], { type: "text/html" });
        setPreviewUrl(URL.createObjectURL(blob));
        
        // Check if tab is hidden - if so, store for immediate display when visible
        if (document.hidden) {
          console.log("Tab hidden - storing code for immediate display when visible");
          pendingCodeRef.current = result.code;
          // DON'T start streaming - the visibility handler will call completeGeneration
        } else {
          // Tab visible - normal streaming flow
          setIsStreamingCode(true);
        }
        // DON'T switch view here - let the streaming completion handler do it (to "preview")
        
        // Extract real stats from code - but DON'T set complete yet (streaming first)
        const buttonCount = (result.code.match(/<button/gi) || []).length;
        const imageCount = (result.code.match(/<img/gi) || []).length;
        const componentCount = (result.code.match(/<section|<header|<footer|<nav|<aside/gi) || []).length;
        
        // Store stats but don't show complete state yet
        setAnalysisPhase(prev => prev ? {
          ...prev,
          structureItems: (prev.structureItems || []).map(s => ({ ...s, status: "done" as const })),
          stats: {
            tech: "Tailwind CSS + Alpine.js",
            componentCount: componentCount + buttonCount,
            imageCount,
            theme: styleDirective || "Modern Design"
          }
        } : prev);
        
        // Add to generation history for persistence
        // Use current title (user can change it manually, default is "Untitled Project")
        const currentTitle = generationTitle || "Untitled Project";
        
        // Create initial version
        const initialVersion: GenerationVersion = {
          id: generateId(),
          timestamp: Date.now(),
          label: "Initial generation",
          code: result.code,
          flowNodes: [],
          flowEdges: [],
          styleInfo: null,
        };
        
        const newGeneration: GenerationRecord = {
          id: generateId(),
          title: currentTitle,
          autoTitle: false,
          timestamp: Date.now(),
          status: "complete",
          code: result.code,
          styleDirective: styleDirective,
          refinements: refinements,
          flowNodes: [], // Will be populated after buildFlowLive
          flowEdges: [],
          styleInfo: null,
          videoUrl: videoUrl,
          thumbnailUrl: flow.thumbnail, // Save video thumbnail for history
          versions: [initialVersion], // Include initial version
          tokenUsage: result.tokenUsage, // Store Gemini API token usage
          costCredits: CREDIT_COSTS.VIDEO_GENERATE, // 75 credits per generation
        };
        setGenerations(prev => [...prev, newGeneration]);
        setActiveGeneration(newGeneration);
        
        // Immediately save to Supabase for cross-device sync
        saveGenerationToSupabase(newGeneration);
        
        // Generation complete - no toast needed, UI shows the result
      } else {
        const errorMsg = result?.error || "Generation failed. Please try again.";
        console.error("Generation failed:", errorMsg);
        setAnalysisDescription(`Error: ${errorMsg}`);
        showToast(errorMsg, "error");
      }
    } catch (error: any) {
      console.error("Generation error:", error);
      // Check for 413 payload too large
      let errorMsg = error.message || "Unknown error occurred";
      if (errorMsg.includes("413") || errorMsg.includes("payload") || errorMsg.includes("too large")) {
        errorMsg = "Video file is too large for processing. Try a shorter clip.";
      }
      setAnalysisDescription(`Error: ${errorMsg}`);
      showToast(errorMsg, "error");
      setIsProcessing(false);
      generationStartTimeRef.current = null;
    } finally {
      // Don't set isProcessing to false here - let the streaming effect handle it
      // isProcessing will be set to false when streaming completes
      // This prevents the loading state from disappearing while code is still being streamed
      
      // Release Wake Lock when generation ends (success or error)
      if (wakeLock) {
        try {
          await wakeLock.release();
          console.log("Wake Lock released");
        } catch (e) {
          console.log("Wake Lock release failed:", e);
        }
      }
    }
  };

  // Generate description based on code content
  const generateAnalysisDescription = (code: string, style: string): string => {
    const hasHeader = /<header|<nav/i.test(code);
    const hasHero = /hero|banner|jumbotron/i.test(code);
    const hasCards = /card|grid.*card/i.test(code);
    const hasForms = /<form|<input/i.test(code);
    const hasFooter = /<footer/i.test(code);
    const buttonCount = (code.match(/<button/gi) || []).length;
    const imageCount = (code.match(/<img/gi) || []).length;
    
    let desc = `Generated a modern ${style || "clean"} web page`;
    
    const features: string[] = [];
    if (hasHeader) features.push("navigation header");
    if (hasHero) features.push("hero section");
    if (hasCards) features.push("card components");
    if (hasForms) features.push("interactive forms");
    if (hasFooter) features.push("footer");
    
    if (features.length > 0) {
      desc += ` featuring ${features.slice(0, 3).join(", ")}`;
      if (features.length > 3) desc += ` and more`;
    }
    
    desc += `. Includes ${buttonCount} interactive button${buttonCount !== 1 ? 's' : ''}`;
    if (imageCount > 0) desc += ` and ${imageCount} image${imageCount !== 1 ? 's' : ''}`;
    desc += `. Built with Tailwind CSS and Alpine.js for smooth interactions and modern styling.`;
    
    return desc;
  };

  const handleEdit = async () => {
    // Prevent double execution
    if (isEditing) {
      console.log('[handleEdit] Already editing, skipping...');
      return;
    }
    
    console.log('[handleEdit] Starting edit...');
    console.log('[handleEdit] editInput:', editInput);
    console.log('[handleEdit] editImages:', editImages.length);
    console.log('[handleEdit] editableCode exists:', !!editableCode);
    
    if ((!editInput.trim() && editImages.length === 0) || !editableCode) {
      console.log('[handleEdit] Early return - no input or no code');
      showToast("Enter a description of what to change", "error");
      return;
    }
    
    // Auth gate
    if (!user) {
      console.log('[handleEdit] No user - showing auth modal');
      setPendingAction("edit");
      setShowAuthModal(true);
      return;
    }
    
    // Credits gate
    if (!canAfford(CREDIT_COSTS.AI_EDIT)) {
      console.log('[handleEdit] Not enough credits');
      setShowOutOfCreditsModal(true);
      return;
    }
    
    // Spend credits
    try {
      console.log('[handleEdit] Spending credits...');
      const spendRes = await fetch("/api/credits/spend", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          cost: CREDIT_COSTS.AI_EDIT,
          reason: "ai_edit",
          referenceId: `edit_${Date.now()}`,
        }),
      });
      const spendData = await spendRes.json();
      console.log('[handleEdit] Spend result:', spendData);
      if (!spendData.success) {
        setShowOutOfCreditsModal(true);
        return;
      }
      refreshCredits();
    } catch (error) {
      console.error("[handleEdit] Failed to spend credits:", error);
      showToast("Failed to process credits", "error");
      return;
    }
    
    setIsEditing(true);
    
    // Extract page name from editInput to track which file is being generated
    const pageMatch = editInput.match(/@([a-zA-Z0-9-_]+)/);
    if (pageMatch) {
      const pageName = pageMatch[1].toLowerCase().replace(/[^a-z0-9]+/g, '-');
      setGeneratingFilePath(`/pages/${pageName}.html`);
    }
    
    try {
      // Include selected node context if any
      let prompt = editInput;
      if (selectedArchNode) {
        prompt = `For the @${selectedArchNode} element: ${editInput}`;
      }
      
      // Process images - use Supabase URLs directly, convert blob URLs to base64
      let imageData: { base64?: string; url?: string; mimeType: string; name: string }[] = [];
      if (editImages.length > 0) {
        console.log('[handleEdit] Processing', editImages.length, 'images');
        for (const img of editImages) {
          try {
            // Check if it's a Supabase URL (public URL)
            if (img.url.startsWith('https://') && !img.url.startsWith('blob:')) {
              // Use URL directly
              console.log('[handleEdit] Using Supabase URL:', img.url);
              imageData.push({
                url: img.url,
                mimeType: 'image/png',
                name: img.name,
              });
            } else {
              // Convert blob URL to base64
              let blob: Blob;
              if (img.file) {
                blob = img.file;
              } else {
                const response = await fetch(img.url);
                blob = await response.blob();
              }
              const base64 = await new Promise<string>((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                  const result = reader.result as string;
                  if (result && result.includes(',')) {
                    const base64Data = result.split(',')[1];
                    resolve(base64Data || '');
                  } else {
                    reject(new Error('Invalid base64 result'));
                  }
                };
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(blob);
              });
              if (base64 && base64.length > 100) {
                imageData.push({
                  base64,
                  mimeType: blob.type || 'image/png',
                  name: img.name,
                });
              }
            }
          } catch (e) {
            console.error('Failed to process image:', img.name, e);
          }
        }
        console.log('[handleEdit] Successfully processed', imageData.length, 'images');
      }
      
      console.log('[handleEdit] Calling editCodeWithAI with prompt:', prompt.substring(0, 100));
      console.log('[handleEdit] Images to send:', imageData.length);
      
      // Get database context if connected
      let editDbContext: string | undefined;
      if (activeGeneration) {
        try {
          const dbCtx = await getDatabaseContext(activeGeneration.id);
          if (dbCtx.isConnected) {
            editDbContext = formatDatabaseContextForPrompt(dbCtx);
            console.log('[handleEdit] Database context loaded:', dbCtx.tables);
          }
        } catch {}
      }
      
      const result = await editCodeWithAI(editableCode, prompt, imageData.length > 0 ? imageData : undefined, editDbContext);
      
      console.log('[handleEdit] Full result:', JSON.stringify({ success: result.success, error: result.error, codeLength: result.code?.length }));
      console.log('[handleEdit] Result code exists:', !!result.code);
      console.log('[handleEdit] Result code type:', typeof result.code);
      
      if (result.success && result.code && result.code.length > 0) {
        console.log('[handleEdit] SUCCESS - Applying code changes...');
        
        // Track analytics
        if (activeGeneration) {
          updateProjectAnalytics(activeGeneration.id, "edit");
        }
        
        // Save current state as a version before applying changes
        if (activeGeneration && generatedCode) {
          console.log('[handleEdit] Saving version...');
          const versionLabel = selectedArchNode 
            ? `AI Edit: @${selectedArchNode}` 
            : `AI Edit: ${editInput.slice(0, 30)}${editInput.length > 30 ? '...' : ''}`;
          
          const newVersion: GenerationVersion = {
            id: generateId(),
            timestamp: Date.now(),
            label: versionLabel,
            code: result.code,
            flowNodes: [...flowNodes],
            flowEdges: [...flowEdges],
            styleInfo: styleInfo ? { ...styleInfo } : null,
          };
          
          setGenerations(prev => prev.map(gen => {
            if (gen.id === activeGeneration.id) {
              const existingVersions = gen.versions || [];
              const updatedVersions = [...existingVersions, newVersion].slice(-20);
              return { ...gen, versions: updatedVersions };
            }
            return gen;
          }));
          
          setActiveGeneration(prev => {
            if (!prev) return prev;
            const existingVersions = prev.versions || [];
            const updatedVersions = [...existingVersions, newVersion].slice(-20);
            // Also save to Supabase for sync
            const updatedGen: GenerationRecord = { 
              ...prev, 
              versions: updatedVersions, 
              code: result.code || prev.code 
            };
            saveGenerationToSupabase(updatedGen);
            return updatedGen;
          });
        }
        
        console.log('[handleEdit] Setting generatedCode...');
        setGeneratedCode(result.code);
        console.log('[handleEdit] Setting editableCode...');
        setEditableCode(result.code);
        console.log('[handleEdit] Setting displayedCode...');
        setDisplayedCode(result.code);
        console.log('[handleEdit] Creating preview URL...');
        if (previewUrl) URL.revokeObjectURL(previewUrl);
        const newPreviewUrl = URL.createObjectURL(new Blob([result.code], { type: "text/html" }));
        setPreviewUrl(newPreviewUrl);
        console.log('[handleEdit] Preview URL created:', newPreviewUrl);
        // Debug: Check if new page was injected
        const pageMatches = result.code.match(/x-show\s*=\s*["']currentPage\s*===\s*['"]([^'"]+)['"]/gi);
        console.log('[handleEdit] Pages found in returned code:', pageMatches?.map(m => m.match(/['"]([^'"]+)['"]$/)?.[1]));
        console.log('[handleEdit] Building architecture...');
        buildArchitectureLive(result.code);
        console.log('[handleEdit] Building flow...');
        buildFlowLive(result.code);
        console.log('[handleEdit] Extracting style info...');
        setStyleInfo(extractStyleInfo(result.code));
        
        // Regenerate file structure with the new code
        const newCode = result.code;
        setTimeout(() => {
          console.log('[handleEdit] Regenerating file structure...');
          const files = generateFileStructure(newCode, flowNodes, codeMode);
          setGeneratedFiles(files);
          setGeneratingFilePath(null);
        }, 100);
        
        console.log('[handleEdit] ALL DONE - showing toast');
        showToast("Changes applied!", "success");
        
        // Switch to preview tab to show the result
        setViewMode("preview");
        
        // Only close panel and clear state on success
        setIsEditing(false);
        setEditInput("");
        setSelectedElement(null);
        editImages.forEach(img => URL.revokeObjectURL(img.url));
        setEditImages([]);
        setShowFloatingEdit(false);
        setSelectedArchNode(null);
      } else {
        // Show error but keep panel open so user can retry
        console.error('[handleEdit] AI edit failed:', result.error);
        showToast(result.error || "Edit failed - try again", "error");
        setIsEditing(false);
        setSelectedElement(null); // Clear pointer selection on error
      }
    } catch (error: any) {
      console.error("Edit error:", error);
      showToast(error.message || "Failed to edit - try again", "error");
      setIsEditing(false);
      setSelectedElement(null); // Clear pointer selection on error
    }
  };

  const applyCodeChanges = () => {
    if (editableCode) {
      // Update the source HTML
      setGeneratedCode(editableCode);
      setDisplayedCode(editableCode);
      if (previewUrl) URL.revokeObjectURL(previewUrl);
      setPreviewUrl(URL.createObjectURL(new Blob([editableCode], { type: "text/html" })));
      setIsCodeEditable(false);
      
      // Regenerate file structure with updated code
      const files = generateFileStructure(editableCode, flowNodes, codeMode);
      setGeneratedFiles(files);
    }
  };
  
  // When entering edit mode, always show the raw HTML for editing
  const handleEnterEditMode = () => {
    setEditableCode(generatedCode || displayedCode);
    setIsCodeEditable(true);
    // Switch to single-file mode for editing the actual HTML
    setCodeMode("single-file");
    setActiveFilePath("/pages/index.html");
  };

  const handleDownload = () => {
    if (!editableCode) return;
    const a = document.createElement("a");
    a.href = URL.createObjectURL(new Blob([editableCode], { type: "text/html" }));
    // Use project title for filename, sanitize for safe filename
    const filename = (generationTitle || "generated")
      .replace(/[^a-zA-Z0-9\s-]/g, "")
      .replace(/\s+/g, "-")
      .toLowerCase()
      .slice(0, 50) || "generated";
    a.download = `${filename}.html`;
    a.click();
  };

  const handlePublishClick = () => {
    if (!editableCode) return;
    // Initialize published URL from active generation if exists
    if (activeGeneration?.publishedSlug) {
      setPublishedUrl(`https://www.replay.build/p/${activeGeneration.publishedSlug}`);
    }
    setShowPublishModal(true);
  };

  const handlePublish = async () => {
    if (!editableCode || isPublishing) return;
    
    setIsPublishing(true);
    try {
      // ONLY use the slug from the active generation - never from publishedUrl state (which could be from a different project)
      const existingSlug = activeGeneration?.publishedSlug;
      console.log('[handlePublish] existingSlug:', existingSlug, 'activeGeneration:', activeGeneration?.id);
      
      const response = await fetch("/api/publish", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          code: editableCode,
          title: generationTitle || "Untitled Project",
          thumbnailDataUrl: null,
          existingSlug,
        }),
      });
      
      const data = await response.json();
      console.log('[handlePublish] API response:', data);
      
      if (data.success && data.url) {
        const newSlug = data.slug;
        setPublishedUrl(data.url);
        
        // Save the slug to the generation record for future updates
        if (newSlug) {
          if (activeGeneration) {
            const updatedGen: GenerationRecord = {
              ...activeGeneration,
              publishedSlug: newSlug,
            };
            setActiveGeneration(updatedGen);
            setGenerations(prev => prev.map(g => 
              g.id === activeGeneration.id ? updatedGen : g
            ));
            // Also save to Supabase
            saveGenerationToSupabase(updatedGen);
          }
          // Also persist to localStorage directly as backup
          try {
            const storedHistory = localStorage.getItem("replay_generation_history");
            if (storedHistory && activeGeneration) {
              const history = JSON.parse(storedHistory);
              const updated = history.map((g: any) => 
                g.id === activeGeneration.id ? { ...g, publishedSlug: newSlug } : g
              );
              localStorage.setItem("replay_generation_history", JSON.stringify(updated));
            }
          } catch (e) {
            console.error("Error saving slug to localStorage:", e);
          }
        }
        
        // Track export analytics
        if (activeGeneration && !data.updated) {
          updateProjectAnalytics(activeGeneration.id, "export");
        }
        
        showToast(data.updated ? "Project updated!" : "Project published!", "success");
      } else {
        showToast(data.error || "Failed to publish", "error");
      }
    } catch (error) {
      console.error("Publish error:", error);
      showToast("Failed to publish project", "error");
    } finally {
      setIsPublishing(false);
    }
  };

  const handleRefresh = () => {
    // Refresh the preview by re-creating the blob URL
    if (editableCode) {
      if (previewUrl) URL.revokeObjectURL(previewUrl);
      setPreviewUrl(URL.createObjectURL(new Blob([editableCode], { type: "text/html" })));
      // Rebuild architecture, flow and style
      buildArchitectureLive(editableCode);
      buildFlowLive(editableCode);
      setStyleInfo(extractStyleInfo(editableCode));
    }
  };

  // Select architecture node and open edit
  const handleArchNodeClick = (nodeId: string) => {
    if (selectedArchNode === nodeId) {
      setSelectedArchNode(null);
    } else if (!isEditing) {
      setSelectedArchNode(nodeId);
      setEditInput(`@${nodeId} `);
      setShowFloatingEdit(true);
    }
  };

  // File Tree Item Component for Code tab
  const FileTreeItem = ({ 
    item, 
    activeFilePath, 
    onFileClick, 
    onFolderToggle,
    expandedFolders,
    generatingPath,
    depth = 0 
  }: { 
    item: FileTreeFolder | FileTreeFile;
    activeFilePath: string;
    onFileClick: (path: string, isStub?: boolean, nodeId?: string) => void;
    onFolderToggle: (path: string) => void;
    expandedFolders: Set<string>;
    generatingPath?: string | null;
    depth?: number;
  }) => {
    const paddingLeft = depth * 12 + 4;
    
    if (item.type === "folder") {
      const folder = item as FileTreeFolder;
      const isExpanded = expandedFolders.has(folder.path);
      const folderColors: Record<string, string> = {
        pages: "text-blue-400/60",
        components: "text-yellow-400/60",
        styles: "text-purple-400/60",
        types: "text-green-400/60",
        layout: "text-cyan-400/60",
        sections: "text-orange-400/60"
      };
      const colorClass = folderColors[folder.name] || "text-white/40";
      
      return (
        <div>
          <button
            onClick={() => onFolderToggle(folder.path)}
            className="w-full flex items-center gap-1 px-1 py-0.5 hover:bg-white/5 rounded text-white/50 transition-colors min-w-0"
            style={{ paddingLeft }}
          >
            <ChevronRight className={cn("w-2.5 h-2.5 flex-shrink-0 transition-transform", isExpanded && "rotate-90")} />
            <Folder className={cn("w-3 h-3 flex-shrink-0", colorClass)} />
            <span className="text-[10px] truncate">{folder.name}</span>
            <span className="flex-shrink-0 ml-auto text-[8px] text-white/20">{folder.children.length}</span>
          </button>
          {isExpanded && (
            <div>
              {folder.children
                .sort((a, b) => {
                  // Folders first, then files
                  if (a.type !== b.type) return a.type === "folder" ? -1 : 1;
                  return a.name.localeCompare(b.name);
                })
                .map((child) => (
                  <FileTreeItem
                    key={child.path}
                    item={child}
                    activeFilePath={activeFilePath}
                    onFileClick={onFileClick}
                    onFolderToggle={onFolderToggle}
                    expandedFolders={expandedFolders}
                    generatingPath={generatingPath}
                    depth={depth + 1}
                  />
                ))}
            </div>
          )}
        </div>
      );
    }
    
    // File
    const file = item as FileTreeFile;
    const isActive = file.path === activeFilePath;
    const isStub = file.isStub;
    const isGenerating = generatingPath === file.path || generatingPath === file.sourceNodeId;
    
    const fileIcons: Record<string, { icon: typeof FileCode; color: string }> = {
      page: { icon: FileCode, color: "text-blue-400" },
      component: { icon: Box, color: "text-yellow-400" },
      style: { icon: Paintbrush, color: "text-purple-400" },
      type: { icon: FileCode, color: "text-green-400" },
      stub: { icon: FileCode, color: "text-white/20" }
    };
    const { icon: FileIcon, color: iconColor } = fileIcons[file.fileType] || fileIcons.page;
    
    return (
      <button
        onClick={() => !isGenerating && onFileClick(file.path, isStub, file.sourceNodeId)}
        className={cn(
          "w-full flex items-center gap-1.5 px-1.5 py-0.5 rounded text-[10px] transition-colors min-w-0",
          isGenerating 
            ? "bg-[#FF6E3C]/5 text-[#FF6E3C]/70 animate-pulse"
            : isActive 
              ? "bg-[#FF6E3C]/10 text-[#FF6E3C]" 
              : isStub 
                ? "text-white/20 hover:bg-white/5 italic" 
                : "text-white/50 hover:bg-white/5 hover:text-white/70"
        )}
        style={{ paddingLeft: paddingLeft + 14 }}
        title={isGenerating ? `Generating ${file.name}...` : isStub ? `${file.name} - Click to create with AI` : file.name}
        disabled={isGenerating}
      >
        {isGenerating ? (
          <Loader2 className="w-3 h-3 flex-shrink-0 text-[#FF6E3C] animate-spin" />
        ) : (
          <FileIcon className={cn("w-3 h-3 flex-shrink-0", isActive ? "text-[#FF6E3C]" : isStub ? "opacity-30" : iconColor)} />
        )}
        <span className={cn("truncate", isStub && "opacity-60", isGenerating && "text-[#FF6E3C]/70")}>{file.name}</span>
        {isGenerating && <span className="flex-shrink-0 ml-auto text-[8px] text-[#FF6E3C]/60 animate-pulse">...</span>}
        {isStub && !isGenerating && <span className="flex-shrink-0 ml-auto text-[7px] text-[#FF6E3C]/50">+</span>}
      </button>
    );
  };

  const EmptyState = ({ icon: Icon, title, subtitle, showEarlyAccess = false }: { icon: any; title: string; subtitle: string; showEarlyAccess?: boolean }) => (
    <div className="empty-state">
      <div className="empty-logo-container">
        {Icon === "logo" ? (
          <svg className="empty-logo" viewBox="0 0 82 109" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M68.099 37.2285C78.1678 43.042 78.168 57.5753 68.099 63.3887L29.5092 85.668C15.6602 93.6633 0.510418 77.4704 9.40857 64.1836L17.4017 52.248C18.1877 51.0745 18.1876 49.5427 17.4017 48.3691L9.40857 36.4336C0.509989 23.1467 15.6602 6.95306 29.5092 14.9482L68.099 37.2285Z" stroke="currentColor" strokeWidth="11.6182" strokeLinejoin="round"/>
            <rect x="34.054" y="98.6841" width="48.6555" height="11.6182" rx="5.80909" transform="rotate(-30 34.054 98.6841)" fill="currentColor"/>
          </svg>
        ) : (
          <Icon className="w-12 h-12 text-white/10 mx-auto" />
        )}
      </div>
      <p className="text-base text-white/25 mt-6">{title}</p>
      <p className="text-lg text-white/15 mt-1">{subtitle}</p>
      {showEarlyAccess && (
        <div className="mt-6 px-4 py-3 rounded-xl bg-[#FF6E3C]/5 border border-[#FF6E3C]/10 max-w-xs">
          <p className="text-xs text-[#FF6E3C]/80 font-medium">Early Access</p>
          <p className="text-[10px] text-white/40 mt-1">We're reconstructing real-world UI behavior  edge cases welcome.</p>
        </div>
      )}
    </div>
  );

  // Stable loading message - doesn't depend on streamingMessage to prevent flickering
  const [loadingMessage, setLoadingMessage] = useState("Reconstructing from video...");
  
  useEffect(() => {
    if (!isProcessing && !isStreamingCode) return;
    
    const msgs = getStreamingMessages();
    let index = 0;
    
    // Set initial message
    setLoadingMessage(msgs[0] || "Reconstructing from video...");
    
    const interval = setInterval(() => {
      index = (index + 1) % msgs.length;
      setLoadingMessage(msgs[index] || "Reconstructing from video...");
    }, 2500);
    
    return () => clearInterval(interval);
  }, [isProcessing, isStreamingCode, viewMode]); // Only depend on stable values
  
  const LoadingState = ({ customMessage }: { customMessage?: string }) => {
    const displayMessage = customMessage || loadingMessage || "Reconstructing from video...";
    
    return (
      <div className="logo-loader">
        <div className="logo-loader-container">
          <svg className="logo-loader-svg" viewBox="0 0 82 109" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M68.099 37.2285C78.1678 43.042 78.168 57.5753 68.099 63.3887L29.5092 85.668C15.6602 93.6633 0.510418 77.4704 9.40857 64.1836L17.4017 52.248C18.1877 51.0745 18.1876 49.5427 17.4017 48.3691L9.40857 36.4336C0.509989 23.1467 15.6602 6.95306 29.5092 14.9482L68.099 37.2285Z" />
            <rect x="34.054" y="98.6841" width="48.6555" height="11.6182" rx="5.80909" transform="rotate(-30 34.054 98.6841)" />
          </svg>
          <div className="logo-loader-gradient" />
        </div>
        <div className="streaming-text">
          <motion.div 
            key={displayMessage}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.4 }}
            className="streaming-text-inner"
          >
            {displayMessage}
          </motion.div>
        </div>
      </div>
    );
  };

  // Render edit input with highlighted @tags
  const renderEditDisplay = () => {
    const parts = editInput.split(/(@\w+)/g);
    return parts.map((part, i) => {
      if (part.startsWith("@")) {
        return <span key={i} className="at-tag">{part}</span>;
      }
      return part;
    });
  };

  return (
    <div className="h-screen flex flex-col bg-[#050505] overflow-hidden font-poppins">
      <div className="gradient-bg" />
      <div className="grain-overlay" />
      <div className="vignette" />
      
      {/* Desktop Header */}
      <header className="relative z-20 hidden md:flex items-center justify-between px-5 py-3 border-b border-white/5 bg-black/60 backdrop-blur-xl">
        <a href="/" className="hover:opacity-80 transition-opacity">
          <Logo />
        </a>
        <div className="flex items-center gap-4">
          <div className="relative">
            {user ? (
              <>
                <button onClick={() => setShowUserMenu(!showUserMenu)} className="p-1 rounded-full hover:bg-white/5 transition-colors">
                  <Avatar 
                    src={profile?.avatar_url} 
                    fallback={user.email?.[0]?.toUpperCase() || "U"} 
                    size={32}
                    className="ring-2 ring-transparent hover:ring-[#FF6E3C]/30 transition-all"
                  />
                </button>
                <AnimatePresence>
                  {showUserMenu && (
                    <motion.div initial={{ opacity: 0, y: 5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: 5 }} className="absolute top-full right-0 mt-2 w-64 bg-[#1a1a1a] border border-white/10 rounded-xl overflow-hidden shadow-2xl z-50">
                      {/* Credits section */}
                      {(() => {
                        const plan = membership?.plan || "free";
                        const maxCredits = plan === "agency" ? 10000 : plan === "pro" ? 3000 : 150;
                        const percentage = Math.min(100, (userTotalCredits / maxCredits) * 100);
                        return (
                          <Link href="/settings?tab=credits" className="block p-3 hover:bg-white/5 transition-colors border-b border-white/5">
                            <div className="flex items-center justify-between mb-2">
                              <span className="text-sm text-white">{userTotalCredits} credits available</span>
                              <ChevronRight className="w-4 h-4 text-white/40" />
                            </div>
                            <div className="w-full h-1.5 bg-white/10 rounded-full overflow-hidden">
                              <div 
                                className="h-full bg-gradient-to-r from-[#FF6E3C] to-[#FF8F5C] rounded-full transition-all"
                                style={{ width: `${percentage}%` }}
                              />
                            </div>
                            <div className="flex items-center justify-between mt-2">
                              <span className="text-xs text-white/40 capitalize">{plan} Plan</span>
                              <Link href="/settings?tab=plans" className="text-xs text-[#FF6E3C] font-medium hover:text-[#FF8F5C]">Upgrade</Link>
                            </div>
                          </Link>
                        );
                      })()}
                      
                      <div className="p-1.5">
                        <Link href="/settings" className="w-full dropdown-item text-left text-sm text-white/80 flex items-center gap-2">
                          <Settings className="w-4 h-4 opacity-50" /> Settings
                        </Link>
                      </div>
                      <div className="p-1.5 border-t border-white/5">
                        <button
                          onClick={() => { setShowUserMenu(false); signOut(); }}
                          className="w-full dropdown-item text-left text-sm text-white/80 flex items-center gap-2"
                        >
                          <LogOut className="w-4 h-4 opacity-50" /> Sign out
                        </button>
                      </div>
                    </motion.div>
                  )}
                </AnimatePresence>
              </>
            ) : (
              <button
                onClick={() => setShowAuthModal(true)}
                className="px-4 py-2 rounded-lg bg-[#FF6E3C] text-white text-sm font-medium hover:bg-[#FF8F5C] transition-colors"
              >
                Sign in
              </button>
            )}
          </div>
        </div>
      </header>
      
      {/* Mobile Header - Fixed */}
      <header className="fixed top-0 left-0 right-0 z-50 flex md:hidden items-center justify-between px-4 py-3 border-b border-white/5 bg-black/95 backdrop-blur-xl">
        <a href="/" className="hover:opacity-80 transition-opacity">
          <Logo />
        </a>
        <button 
          onClick={() => setShowMobileMenu(!showMobileMenu)}
          className="p-2 rounded-lg hover:bg-white/5 transition-colors"
        >
          {user ? (
            <Avatar 
              src={profile?.avatar_url} 
              fallback={user.email?.[0]?.toUpperCase() || "U"} 
              size={28}
            />
          ) : (
            <User className="w-5 h-5 text-white/60" />
          )}
        </button>
      </header>
      
      {/* Mobile Menu Overlay */}
      <AnimatePresence>
        {showMobileMenu && (
          <motion.div 
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm md:hidden"
            onClick={() => setShowMobileMenu(false)}
          >
            <motion.div 
              initial={{ x: "100%" }}
              animate={{ x: 0 }}
              exit={{ x: "100%" }}
              transition={{ type: "spring", damping: 25, stiffness: 300 }}
              className="absolute right-0 top-0 bottom-0 w-72 bg-[#111] border-l border-white/10"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="p-4 border-b border-white/5">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium text-white">Menu</span>
                  <button onClick={() => setShowMobileMenu(false)} className="p-1 hover:bg-white/10 rounded">
                    <X className="w-5 h-5 text-white/60" />
                  </button>
                </div>
              </div>
              
              {user ? (
                <>
                  {/* Credits section */}
                  {(() => {
                    const plan = membership?.plan || "free";
                    const maxCredits = plan === "agency" ? 10000 : plan === "pro" ? 3000 : 150;
                    const percentage = Math.min(100, (userTotalCredits / maxCredits) * 100);
                    return (
                      <Link 
                        href="/settings?tab=plans" 
                        onClick={() => setShowMobileMenu(false)}
                        className="block p-4 hover:bg-white/5 transition-colors border-b border-white/5"
                      >
                        <div className="flex items-center justify-between mb-2">
                          <span className="text-sm text-white">{userTotalCredits} credits available</span>
                          <ChevronRight className="w-4 h-4 text-white/40" />
                        </div>
                        <div className="w-full h-1.5 bg-white/10 rounded-full overflow-hidden">
                          <div 
                            className="h-full bg-gradient-to-r from-[#FF6E3C] to-[#FF8F5C] rounded-full transition-all"
                            style={{ width: `${percentage}%` }}
                          />
                        </div>
                        <div className="flex items-center justify-between mt-2">
                          <span className="text-xs text-white/40 capitalize">{plan} Plan</span>
                          <span className="text-xs text-[#FF6E3C] font-medium">Upgrade</span>
                        </div>
                      </Link>
                    );
                  })()}
                  
                  <div className="p-2 space-y-1">
                    <Link 
                      href="/settings" 
                      onClick={() => setShowMobileMenu(false)}
                      className="flex items-center gap-3 px-3 py-3 rounded-lg hover:bg-white/5 text-white/80"
                    >
                      <Settings className="w-4 h-4 opacity-50" /> Settings
                    </Link>
                  </div>
                  <div className="p-2 border-t border-white/5">
                    <button 
                      onClick={() => { setShowMobileMenu(false); signOut(); }}
                      className="w-full flex items-center gap-3 px-3 py-3 rounded-lg hover:bg-white/5 text-white/80"
                    >
                      <LogOut className="w-4 h-4 opacity-50" /> Sign out
                    </button>
                  </div>
                </>
              ) : (
                <div className="p-4">
                  <button
                    onClick={() => { setShowMobileMenu(false); setShowAuthModal(true); }}
                    className="w-full py-3 rounded-xl bg-[#FF6E3C] text-white font-medium hover:bg-[#FF8F5C] transition-colors"
                  >
                    Sign in
                  </button>
                </div>
              )}
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      <div className="flex-1 flex overflow-hidden relative z-10">
        {/* Left Panel - Hidden on mobile */}
        <div className="hidden md:flex w-[340px] border-r border-white/5 bg-black/40 backdrop-blur-sm flex-col">
          
          {/* HISTORY MODE */}
          {showHistoryMode ? (
            <div className="flex-1 flex flex-col min-h-0 overflow-hidden">
              {/* History Header - One line: History + Back */}
              <div className="flex-shrink-0 p-4 border-b border-white/5">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <History className="w-4 h-4 text-white/40" />
                    <span className="text-xs font-semibold text-white/60 uppercase tracking-wider">History</span>
                  </div>
                  <button 
                    onClick={() => setShowHistoryMode(false)}
                    className="flex items-center gap-1 text-xs text-white/50 hover:text-white transition-colors"
                  >
                    <span>Back</span>
                    <ChevronRight className="w-3 h-3" />
                  </button>
                </div>
                {/* Search */}
                <div className="mt-3 relative">
                  <Search className="absolute left-2.5 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-white/30" />
                  <input
                    type="text"
                    value={historySearch}
                    onChange={(e) => setHistorySearch(e.target.value)}
                    placeholder="Search projects..."
                    className="w-full pl-8 pr-3 py-2 rounded-lg bg-white/[0.03] border border-white/[0.06] text-xs text-white/70 placeholder:text-white/30 focus:outline-none focus:border-white/10"
                  />
                </div>
              </div>
              
              {/* Generation List - sorted newest first */}
              <div className="flex-1 min-h-0 overflow-y-auto custom-scrollbar p-2">
                {generations.length === 0 ? (
                  <div className="text-center py-12">
                    <History className="w-8 h-8 text-white/10 mx-auto mb-3" />
                    <p className="text-sm text-white/40">No generations yet</p>
                    <p className="text-xs text-white/25 mt-1">Your generation history will appear here</p>
                  </div>
                ) : (
                  <div className="space-y-1">
                    {generations
                      .slice()
                      .sort((a, b) => b.timestamp - a.timestamp)
                      .filter(gen => !historySearch || gen.title.toLowerCase().includes(historySearch.toLowerCase()))
                      .map((gen) => (
                      <div 
                        key={gen.id}
                        className={cn(
                          "group relative p-3 rounded-lg cursor-pointer transition-colors hover:bg-white/5",
                          activeGeneration?.id === gen.id && "bg-[#FF6E3C]/10 border border-[#FF6E3C]/20"
                        )}
                        onClick={() => {
                          if (renamingId === gen.id) return; // Don't load while renaming
                          
                          // Ensure generation has versions - if not, create initial version from code
                          let genToLoad = gen;
                          if (gen.code && (!gen.versions || gen.versions.length === 0)) {
                            const initialVersion: GenerationVersion = {
                              id: generateId(),
                              timestamp: gen.timestamp,
                              label: "Initial generation",
                              code: gen.code,
                              flowNodes: gen.flowNodes || [],
                              flowEdges: gen.flowEdges || [],
                              styleInfo: gen.styleInfo || null,
                            };
                            genToLoad = { ...gen, versions: [initialVersion] };
                            // Update in generations list
                            setGenerations(prev => prev.map(g => g.id === gen.id ? genToLoad : g));
                          }
                          
                          // Load this generation
                          setActiveGeneration(genToLoad);
                          setGenerationTitle(genToLoad.title);
                          // Reset published URL state to match the loaded generation
                          setPublishedUrl(genToLoad.publishedSlug ? `https://www.replay.build/p/${genToLoad.publishedSlug}` : null);
                          setShowPublishModal(false);
                          if (genToLoad.code) {
                            setGeneratedCode(genToLoad.code);
                            setDisplayedCode(genToLoad.code);
                            setEditableCode(genToLoad.code);
                            const blob = new Blob([genToLoad.code], { type: "text/html" });
                            setPreviewUrl(URL.createObjectURL(blob));
                          }
                          if (genToLoad.flowNodes) setFlowNodes(genToLoad.flowNodes);
                          if (genToLoad.flowEdges) setFlowEdges(genToLoad.flowEdges);
                          if (genToLoad.styleInfo) setStyleInfo(genToLoad.styleInfo);
                          setStyleDirective(genToLoad.styleDirective);
                          setRefinements(genToLoad.refinements);
                          
                          // Auto-expand versions if there are any
                          if (genToLoad.versions && genToLoad.versions.length > 0) {
                            setExpandedVersions(genToLoad.id);
                          }
                          
                          // Restore video from generation if available
                          if (genToLoad.videoUrl && !flows.some(f => f.videoUrl === genToLoad.videoUrl)) {
                            const newFlow: FlowItem = {
                              id: generateId(),
                              name: genToLoad.title || "Recording",
                              videoBlob: new Blob(), // Empty blob as placeholder
                              videoUrl: genToLoad.videoUrl,
                              thumbnail: genToLoad.thumbnailUrl || "",
                              duration: 30,
                              trimStart: 0,
                              trimEnd: 30,
                            };
                            setFlows([newFlow]);
                            setSelectedFlowId(newFlow.id);
                          }
                          setShowHistoryMode(false);
                          setGenerationComplete(true);
                        }}
                      >
                        <div className="flex items-start justify-between">
                          <div className="flex-1 min-w-0">
                            <div className="flex items-center gap-2">
                              {renamingId === gen.id ? (
                                <input
                                  type="text"
                                  value={renameValue}
                                  onChange={(e) => setRenameValue(e.target.value)}
                                  onBlur={() => renameGeneration(gen.id, renameValue || gen.title)}
                                  onKeyDown={(e) => {
                                    if (e.key === "Enter") renameGeneration(gen.id, renameValue || gen.title);
                                    if (e.key === "Escape") { setRenamingId(null); setRenameValue(""); }
                                  }}
                                  onClick={(e) => e.stopPropagation()}
                                  autoFocus
                                  className="flex-1 min-w-0 text-sm font-medium text-white/80 bg-white/5 border border-white/10 rounded px-2 py-0.5 focus:outline-none focus:border-[#FF6E3C]/50"
                                />
                              ) : (
                                <p className="text-sm font-medium text-white/80 truncate">{gen.title}</p>
                              )}
                            </div>
                            <p className="text-[10px] text-white/30 mt-1">
                              {new Date(gen.timestamp).toLocaleDateString()}  {new Date(gen.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                            </p>
                          </div>
                          
                          {/* Actions menu */}
                          <div className="relative">
                            <button 
                              onClick={(e) => { 
                                e.stopPropagation(); 
                                setHistoryMenuOpen(historyMenuOpen === gen.id ? null : gen.id);
                              }}
                              className={cn(
                                "p-1.5 rounded hover:bg-white/10 transition-opacity",
                                historyMenuOpen === gen.id ? "opacity-100" : "opacity-0 group-hover:opacity-100"
                              )}
                            >
                              <MoreVertical className="w-4 h-4 text-white/40" />
                            </button>
                            
                            {/* Dropdown menu */}
                            <AnimatePresence>
                              {historyMenuOpen === gen.id && (
                                <motion.div 
                                  initial={{ opacity: 0, scale: 0.95, y: -5 }}
                                  animate={{ opacity: 1, scale: 1, y: 0 }}
                                  exit={{ opacity: 0, scale: 0.95, y: -5 }}
                                  className="absolute right-0 top-8 z-50 w-32 bg-[#151515] border border-white/10 rounded-lg shadow-xl overflow-hidden"
                                  onClick={(e) => e.stopPropagation()}
                                >
                                  <button
                                    onClick={() => { 
                                      setRenamingId(gen.id); 
                                      setRenameValue(gen.title); 
                                      setHistoryMenuOpen(null);
                                    }}
                                    className="w-full px-3 py-2 text-left text-xs text-white/70 hover:bg-white/5 flex items-center gap-2"
                                  >
                                    <Pencil className="w-3 h-3" /> Rename
                                  </button>
                                  <button
                                    onClick={() => duplicateGeneration(gen)}
                                    className="w-full px-3 py-2 text-left text-xs text-white/70 hover:bg-white/5 flex items-center gap-2"
                                  >
                                    <Copy className="w-3 h-3" /> Duplicate
                                  </button>
                                  <button
                                    onClick={() => deleteGeneration(gen.id)}
                                    className="w-full px-3 py-2 text-left text-xs text-red-400/80 hover:bg-red-500/10 flex items-center gap-2"
                                  >
                                    <Trash2 className="w-3 h-3" /> Delete
                                  </button>
                                </motion.div>
                              )}
                            </AnimatePresence>
                          </div>
                        </div>
                        
                        {/* Style & Context hints */}
                        {(gen.styleDirective || gen.refinements) && (
                          <div className="mt-1.5 space-y-0.5">
                            {gen.styleDirective && (
                              <p className="text-[10px] text-white/25 truncate">
                                <span className="text-white/15">Style:</span> {gen.styleDirective}
                              </p>
                            )}
                            {gen.refinements && (
                              <p className="text-[10px] text-white/20 truncate italic">
                                <span className="text-white/15">Context:</span> {gen.refinements}
                              </p>
                            )}
                          </div>
                        )}
                        
                        {/* Version History Toggle */}
                        {gen.versions && gen.versions.length >= 1 && (
                          <div className="mt-2 pt-2 border-t border-white/5">
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                setExpandedVersions(expandedVersions === gen.id ? null : gen.id);
                              }}
                              className="flex items-center gap-2 text-[10px] text-white/40 hover:text-white/60 transition-colors"
                            >
                              <Clock className="w-3 h-3" />
                              <span>{gen.versions.length} version{gen.versions.length !== 1 ? 's' : ''}</span>
                              <ChevronDown className={cn(
                                "w-3 h-3 transition-transform",
                                expandedVersions === gen.id && "rotate-180"
                              )} />
                            </button>
                            
                            {/* Expanded Versions List */}
                            <AnimatePresence>
                              {expandedVersions === gen.id && (
                                <motion.div
                                  initial={{ opacity: 0, height: 0 }}
                                  animate={{ opacity: 1, height: "auto" }}
                                  exit={{ opacity: 0, height: 0 }}
                                  className="mt-2 ml-1 space-y-1 overflow-hidden"
                                >
                                  {/* Version timeline */}
                                  <div className="relative pl-3 border-l border-white/10">
                                    {gen.versions.slice().reverse().map((version, idx) => (
                                      <div 
                                        key={version.id}
                                        className="relative py-1.5 group/version"
                                      >
                                        {/* Timeline dot */}
                                        <div className={cn(
                                          "absolute -left-[7px] top-2.5 w-2.5 h-2.5 rounded-full border-2",
                                          idx === 0 
                                            ? "bg-[#FF6E3C] border-[#FF6E3C]" 
                                            : "bg-[#0a0a0a] border-white/20 group-hover/version:border-white/40"
                                        )} />
                                        
                                        <div className="flex items-center justify-between gap-2 pl-2">
                                          <div className="flex-1 min-w-0">
                                            <p className="text-[10px] text-white/50 truncate">{version.label}</p>
                                            <p className="text-[8px] text-white/25">
                                              {new Date(version.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                            </p>
                                          </div>
                                          
                                          {/* Restore button */}
                                          {idx !== 0 && (
                                            <button
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                restoreVersion(gen.id, version);
                                              }}
                                              className="opacity-0 group-hover/version:opacity-100 p-1 rounded hover:bg-white/10 transition-all"
                                              title="Restore this version"
                                            >
                                              <Play className="w-3 h-3 text-[#FF6E3C]" />
                                            </button>
                                          )}
                                          
                                          {idx === 0 && (
                                            <span className="text-[8px] text-[#FF6E3C]/60 uppercase">Current</span>
                                          )}
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                </motion.div>
                              )}
                            </AnimatePresence>
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          ) : (
            /* ACTIVE GENERATION MODE */
            <div className="flex-1 flex flex-col min-h-0 overflow-y-auto custom-scrollbar">
              {/* Generation Title Header - One line: Title + New + History */}
              <div className="p-4 border-b border-white/5">
                <div className="flex items-center gap-2">
                  <div className="flex-1 min-w-0 flex items-center gap-1.5 group">
                    <input 
                      ref={titleInputRef}
                      type="text"
                      value={generationTitle}
                      onChange={(e) => {
                        const newTitle = e.target.value;
                        setGenerationTitle(newTitle);
                        // Auto-save title to active generation and history
                        if (activeGeneration) {
                          setActiveGeneration(prev => prev ? { ...prev, title: newTitle } : null);
                          setGenerations(prev => prev.map(g => 
                            g.id === activeGeneration.id ? { ...g, title: newTitle } : g
                          ));
                        }
                      }}
                      className="flex-1 min-w-0 text-sm font-medium text-white/80 bg-transparent border-none focus:outline-none truncate hover:text-white transition-colors cursor-text"
                      placeholder="Untitled Project"
                    />
                    <button 
                      onClick={() => titleInputRef.current?.focus()}
                      className="p-0.5 hover:bg-white/5 rounded transition-colors"
                      title="Edit name"
                    >
                      <Pencil className="w-3 h-3 text-white/20 group-hover:text-white/40 transition-colors flex-shrink-0" />
                    </button>
                  </div>
                  <button 
                    onClick={() => {
                      // Create new generation - reset state
                      setGeneratedCode(null);
                      setDisplayedCode("");
                      setEditableCode("");
                      setPreviewUrl(null);
                      setFlowNodes([]);
                      setFlowEdges([]);
                      setStyleInfo(null);
                      setGenerationTitle("Untitled Project");
                      setGenerationComplete(false);
                      setViewMode("input");
                    }}
                    className="p-1.5 rounded-lg hover:bg-white/5 transition-colors group"
                    title="New generation"
                  >
                    <Plus className="w-4 h-4 text-white/40 group-hover:text-white/60" />
                  </button>
                  {generations.length > 0 && (
                    <button 
                      onClick={() => setShowHistoryMode(true)}
                      className="p-1.5 rounded-lg hover:bg-white/5 transition-colors group"
                      title="View history"
                    >
                      <History className="w-4 h-4 text-white/40 group-hover:text-white/60" />
                    </button>
                  )}
                  <button 
                    onClick={() => setShowProjectSettings(true)}
                    className="p-1.5 rounded-lg hover:bg-white/5 transition-colors group"
                    title="Project settings"
                  >
                    <Settings className="w-4 h-4 text-white/40 group-hover:text-white/60" />
                  </button>
                </div>
              </div>
              
              {/* Videos Section */}
              <div className="p-4 border-b border-white/5">
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center gap-2">
                    <Video className="w-4 h-4 text-white/40" />
                    <span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Videos</span>
                    {flows.length > 0 && <span className="px-1.5 py-0.5 bg-white/5 rounded text-[10px] text-white/40">{flows.length}</span>}
                  </div>
                  <div className="flex gap-1.5">
                    {isRecording ? (
                      <button onClick={stopRecording} className="btn-black flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs">
                        <Square className="w-3 h-3 fill-red-500 text-red-500" />{formatDuration(recordingDuration)}
                      </button>
                    ) : (
                      <button onClick={startRecording} className="btn-black flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs"><Monitor className="w-3.5 h-3.5" /> Record</button>
                    )}
                    <button onClick={() => fileInputRef.current?.click()} className="btn-black flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs"><Upload className="w-3.5 h-3.5" /> Upload</button>
                  </div>
                </div>
                <div className="space-y-2 max-h-[140px] overflow-auto custom-scrollbar">
                  {flows.length === 0 ? (
                    <div 
                      onClick={() => fileInputRef.current?.click()} 
                      className="relative rounded-xl border-2 border-dashed border-white/[0.08] bg-white/[0.02] hover:border-white/[0.15] hover:bg-white/[0.03] transition-all cursor-pointer"
                    >
                      <div className="p-5 text-center">
                        <Video className="w-5 h-5 text-white/30 mx-auto mb-2" />
                        <p className="text-[10px] text-white/40">
                          Drop your video here
                        </p>
                        <p className="text-[9px] text-white/25 mt-1">
                          Screen recording, product demo, or UI walkthrough
                        </p>
                      </div>
                    </div>
                  ) : flows.map((flow) => (
                    <div key={flow.id} onClick={() => setSelectedFlowId(flow.id)} className={cn("flow-item flex items-center gap-2.5 p-2 cursor-pointer group", selectedFlowId === flow.id && "selected")}>
                      <div className="w-14 h-8 rounded overflow-hidden bg-white/5 flex-shrink-0 flex items-center justify-center">
                        {flow.thumbnail ? <img src={flow.thumbnail} alt="" className="w-full h-full object-cover" /> : <Film className="w-3 h-3 text-white/20" />}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="text-sm font-medium text-white/80 truncate">{flow.name}</p>
                        <p className="text-xs text-white/40">
                          {formatDuration(flow.trimEnd - flow.trimStart)} / {formatDuration(flow.duration)}
                        </p>
                      </div>
                      <button onClick={(e) => { e.stopPropagation(); removeFlow(flow.id); }} className="p-1 opacity-0 group-hover:opacity-100 hover:bg-white/10 rounded"><Trash2 className="w-3 h-3 text-white/40" /></button>
                    </div>
                  ))}
                  
                  {/* Add video button */}
                  {flows.length > 0 && (
                    <button 
                      onClick={() => fileInputRef.current?.click()} 
                      className="w-full flex items-center justify-center gap-1.5 px-3 py-2 rounded-lg text-xs text-white/40 hover:text-white/60 hover:bg-white/5 border border-dashed border-white/10 hover:border-white/20 transition-colors"
                    >
                      <Plus className="w-3 h-3" />
                      <span>Add video</span>
                    </button>
                  )}
                </div>
              </div>
              {/* CONTEXT Section - Above Style */}
              <div className="p-4 border-b border-white/5">
                <div className="flex items-center gap-2 mb-3">
                  <Sparkles className="w-4 h-4 text-white/40" />
                  <span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Context</span>
                </div>
                
                {/* Textarea only */}
                <textarea
                  value={refinements}
                  onChange={(e) => setRefinements(e.target.value)}
                  placeholder="Describe what you observed (optional)"
                  disabled={isProcessing}
                  rows={3}
                  className={cn(
                    "w-full px-3 py-3 rounded-lg text-xs text-white/70 placeholder:text-white/30 placeholder:text-[11px] transition-colors focus:outline-none textarea-grow input-subtle min-h-[80px]",
                    isProcessing && "opacity-50 cursor-not-allowed"
                  )}
                />
              </div>

              <div className="p-4 border-b border-white/5">
                <div className="flex items-center gap-2 mb-3"><Palette className="w-4 h-4 text-white/40" /><span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Style</span></div>
                <StyleInjector 
                  value={styleDirective} 
                  onChange={setStyleDirective} 
                  disabled={isProcessing}
                  referenceImage={styleReferenceImage}
                  onReferenceImageChange={setStyleReferenceImage}
                />
              </div>

              {/* Generate Button */}
              <div className="p-4 border-b border-white/5">
                {(() => {
                  // Determine if we're in update mode (existing project + changed context)
                  const hasProject = activeGeneration && generatedCode && generationComplete;
                  const hasContextChange = refinements.trim() !== (activeGeneration?.refinements || "").trim();
                  const hasStyleChange = styleDirective.trim() !== (activeGeneration?.styleDirective || "").trim();
                  const isUpdateMode = hasProject && (hasContextChange || hasStyleChange) && refinements.trim();
                  
                  return (
                    <button onClick={handleGenerate} disabled={isProcessing || isEditing || flows.length === 0} className={cn("w-full flex items-center justify-center gap-2.5 py-3.5 rounded-xl font-semibold text-sm transition-all btn-generate", (isProcessing || isEditing) && "processing")}>
                      <div className="btn-generate-grain" />
                      <span className="relative z-10 flex items-center gap-2.5">
                        {isProcessing || isEditing ? (
                          <><Loader2 className="w-4 h-4 animate-spin" /><span className="generating-text">{isEditing ? "Updating..." : "Reconstructing..."}</span></>
                        ) : (
                          <><LogoIcon className="btn-logo-icon" color="#FF6E3C" /><span>Reconstruct</span><ChevronRight className="w-4 h-4" /></>
                        )}
                      </span>
                    </button>
                  );
                })()}
              </div>

              {/* Analysis Section - now scrolls with everything */}
              <div className="border-b border-white/5">
                <div className="px-4 py-3 border-b border-white/5 flex items-center gap-2"><Activity className="w-4 h-4 text-white/40" /><span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Analysis</span></div>
                <div ref={analysisRef} className="p-4">
              {(isProcessing || isStreamingCode) && analysisPhase ? (
                <div className="space-y-4">
                  {/* UX SIGNALS - Real-time streaming of what AI observes */}
                  <motion.div 
                    initial={{ opacity: 0, y: 10 }} 
                    animate={{ opacity: 1, y: 0 }} 
                    className="analysis-section"
                  >
                    <div className="flex items-center gap-2 mb-2">
                      <Activity className="w-3.5 h-3.5 text-[#FF6E3C]/60" />
                      <span className="text-[10px] font-semibold text-white/40 uppercase tracking-wider">UX Signals</span>
                      {analysisSection === "style" && <Loader2 className="w-3 h-3 animate-spin text-[#FF6E3C]/50 ml-auto" />}
                    </div>
                    <div className="space-y-1.5">
                      {/* Live streaming UX observations - real-time, not mocked */}
                      {analysisPhase.uxSignals && analysisPhase.uxSignals.length > 0 ? (
                        analysisPhase.uxSignals.map((signal, i) => (
                          <motion.div 
                            key={signal.label}
                            initial={{ opacity: 0, x: -10 }}
                            animate={{ opacity: 1, x: 0 }}
                            transition={{ delay: i * 0.1 }}
                            className="flex items-center justify-between"
                          >
                            <span className="text-[10px] text-white/30">{signal.label}</span>
                            <span className={cn(
                              "text-[10px]",
                              signal.value.includes("...") ? "text-[#FF6E3C]/60" : "text-white/50"
                            )}>
                              {signal.value}
                            </span>
                          </motion.div>
                        ))
                      ) : (
                        <div className="flex items-center gap-2 text-[10px] text-white/30">
                          <Loader2 className="w-3 h-3 animate-spin text-[#FF6E3C]/50" />
                          <span>Detecting UX patterns...</span>
                        </div>
                      )}
                    </div>
                  </motion.div>
                  
                  {/* STRUCTURE & COMPONENTS - Real-time streaming */}
                  <AnimatePresence>
                    {(analysisSection === "layout" || analysisSection === "components") && (
                      <motion.div 
                        initial={{ opacity: 0, y: 10 }} 
                        animate={{ opacity: 1, y: 0 }} 
                        exit={{ opacity: 0 }}
                        className="analysis-section"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <GitBranch className="w-3.5 h-3.5 text-[#FF6E3C]/60" />
                          <span className="text-[10px] font-semibold text-white/40 uppercase tracking-wider">Structure & Components</span>
                          {analysisSection === "layout" && <Loader2 className="w-3 h-3 animate-spin text-[#FF6E3C]/50 ml-auto" />}
                          {analysisSection === "components" && <Check className="w-3 h-3 text-green-500/50 ml-auto" />}
                        </div>
                        <div className="space-y-1">
                          {/* Real-time structure detection */}
                          {analysisPhase.structureItems && analysisPhase.structureItems.length > 0 ? (
                            analysisPhase.structureItems.map((item, i) => (
                              <motion.div 
                                key={item.name}
                                initial={{ opacity: 0, x: -10 }}
                                animate={{ opacity: 1, x: 0 }}
                                className="flex items-center gap-2"
                              >
                                {item.status === "done" ? (
                                  <Check className="w-3 h-3 text-green-500/70" />
                                ) : item.status === "generating" ? (
                                  <Loader2 className="w-3 h-3 animate-spin text-[#FF6E3C]/70" />
                                ) : (
                                  <div className="w-3 h-3 rounded-full border border-white/10" />
                                )}
                                <span className={cn(
                                  "text-[10px]", 
                                  item.status === "done" ? "text-white/60" : 
                                  item.status === "generating" ? "text-[#FF6E3C]/70" : "text-white/30"
                                )}>
                                  {item.name}
                                </span>
                              </motion.div>
                            ))
                          ) : (
                            <div className="flex items-center gap-2 text-[10px] text-white/30">
                              <Loader2 className="w-3 h-3 animate-spin text-[#FF6E3C]/50" />
                              <span>Scanning structure...</span>
                            </div>
                          )}
                        </div>
                      </motion.div>
                    )}
                  </AnimatePresence>
                </div>
              ) : generationComplete && analysisPhase?.stats ? (
                <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} className="space-y-3">
                  <div className="flex items-center gap-2 mb-2">
                    <LogoIcon className="w-4 h-5" color="#FF6E3C" />
                    <span className="text-xs font-medium text-white/60">Complete</span>
                  </div>
                  
                  {/* Stats tiles - compact single line */}
                  <div className="space-y-2">
                    <div className="flex items-center justify-between">
                      <span className="text-xs text-white/40">Stack</span>
                      <span className="text-xs text-white/70 font-medium">Tailwind + Alpine</span>
                    </div>
                    <div className="flex items-center justify-between">
                      <span className="text-xs text-white/40">Elements</span>
                      <span className="text-xs text-white/70 font-medium">{analysisPhase.stats.componentCount}</span>
                    </div>
                    <div className="flex items-center justify-between">
                      <span className="text-xs text-white/40">Style</span>
                      <span className="text-xs text-white/70 font-medium truncate max-w-[140px]">{analysisPhase.stats.theme.split(' ')[0]}</span>
                    </div>
                  </div>
                  
                  {/* Show actual colors from generated code */}
                  {styleInfo && styleInfo.colors.length > 0 && (
                    <div className="flex items-center gap-2 pt-2 border-t border-white/5">
                      <span className="text-xs text-white/30">Colors:</span>
                      <div className="flex gap-1">
                        {styleInfo.colors.slice(0, 5).map((c, i) => (
                          <div key={i} className="w-5 h-5 rounded-sm border border-white/10" style={{ background: c.value }} title={c.value} />
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {analysisDescription && (
                    <p className="text-xs text-white/40 leading-relaxed mt-2 pt-2 border-t border-white/5">
                      {analysisDescription}
                    </p>
                  )}
                </motion.div>
              ) : (
                <div className="analysis-section">
                  <div className="flex items-center gap-2 mb-2">
                    <Clock className="w-3.5 h-3.5 text-white/20" />
                    <span className="text-xs font-semibold text-white/30 uppercase tracking-wider">Waiting for generation</span>
                  </div>
                  <p className="text-xs text-white/25 leading-relaxed">Live analysis logs will display here once generation starts.</p>
                </div>
              )}
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Main Content */}
        <div className="flex-1 flex flex-col bg-[#0a0a0a] min-w-0 overflow-hidden">
          {/* Desktop Tabs */}
          <div className="hidden md:flex items-center justify-between px-4 py-2 border-b border-white/5 bg-black/40">
            <div className="flex items-center gap-1 bg-black/40 rounded-lg p-0.5">
              {[
                { id: "preview", icon: Eye, label: "Preview" },
                { id: "code", icon: Code, label: "Code" },
                { id: "flow", icon: GitBranch, label: "Flow" },
                { id: "design", icon: Paintbrush, label: "Design System" },
                { id: "input", icon: FileInput, label: "Input" },
              ].map((tab) => (
                <button key={tab.id} onClick={() => setViewMode(tab.id as ViewMode)} className={cn("flex items-center gap-1.5 px-3 py-1.5 rounded-md text-xs font-medium transition-colors", viewMode === tab.id ? "bg-white/10 text-white" : "text-white/40 hover:text-white/60")}>
                  <tab.icon className="w-3.5 h-3.5" />{tab.label}
                </button>
              ))}
            </div>
            <div className="flex items-center gap-2">
              {viewMode === "flow" && (
                <div className="flex items-center gap-1 mr-2">
                  <button onClick={() => setArchZoom(z => Math.max(0.5, z - 0.1))} className="btn-black p-1.5 rounded-lg"><ZoomOut className="w-3.5 h-3.5" /></button>
                  <span className="text-xs text-white/40 w-12 text-center">{Math.round(archZoom * 100)}%</span>
                  <button onClick={() => setArchZoom(z => Math.min(2, z + 0.1))} className="btn-black p-1.5 rounded-lg"><ZoomIn className="w-3.5 h-3.5" /></button>
                </div>
              )}
              {viewMode === "code" && editableCode && !isCodeEditable && (
                <button onClick={handleEnterEditMode} className="btn-black flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs"><Pencil className="w-3.5 h-3.5" /> Edit</button>
              )}
              {viewMode === "code" && isCodeEditable && (
                <button onClick={applyCodeChanges} className="btn-black flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs text-green-400"><Check className="w-3.5 h-3.5" /> Apply</button>
              )}
              {editableCode && (
                <>
                  {viewMode === "preview" && (
                    <button 
                      onClick={() => setIsMobilePreview(!isMobilePreview)} 
                      className={cn("btn-black p-1.5 rounded-lg", isMobilePreview && "bg-[#FF6E3C]/20 text-[#FF6E3C]")} 
                      title={isMobilePreview ? "Desktop view" : "Mobile view"}
                    >
                      {isMobilePreview ? <Monitor className="w-3.5 h-3.5" /> : <Smartphone className="w-3.5 h-3.5" />}
                    </button>
                  )}
                  <button onClick={handleRefresh} className="btn-black p-1.5 rounded-lg" title="Refresh"><RefreshCw className="w-3.5 h-3.5" /></button>
                  <button onClick={handleDownload} className="btn-black flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs"><Download className="w-3.5 h-3.5" /> Download</button>
                  
                  {/* Publish dropdown */}
                  <div className="relative">
                    <button 
                      onClick={handlePublishClick}
                      className={cn(
                        "btn-black flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs",
                        activeGeneration?.publishedSlug ? "bg-emerald-500/20 text-emerald-400" : "bg-white/10"
                      )}
                    >
                      <ExternalLink className="w-3.5 h-3.5" />
                      {activeGeneration?.publishedSlug ? "Published" : "Publish"}
                    </button>
                    
                    {/* Publish Dropdown */}
                    <AnimatePresence>
                      {showPublishModal && (
                        <>
                          {/* Backdrop */}
                          <div 
                            className="fixed inset-0 z-40"
                            onClick={() => setShowPublishModal(false)}
                          />
                          <motion.div
                            initial={{ opacity: 0, y: -8, scale: 0.95 }}
                            animate={{ opacity: 1, y: 0, scale: 1 }}
                            exit={{ opacity: 0, y: -8, scale: 0.95 }}
                            transition={{ duration: 0.15 }}
                            className="absolute top-full right-0 mt-2 w-80 bg-[#141414] border border-white/10 rounded-xl shadow-2xl z-50 overflow-hidden"
                          >
                            <div className="p-4">
                              <h3 className="text-sm font-semibold text-white mb-3">Publish your project</h3>
                              
                              {publishedUrl || activeGeneration?.publishedSlug ? (
                                <div className="space-y-3">
                                  <div className="flex items-center gap-2 p-2.5 bg-white/5 rounded-lg border border-white/10">
                                    <div className="w-6 h-6 rounded-full bg-emerald-500/20 flex items-center justify-center flex-shrink-0">
                                      <Check className="w-3 h-3 text-emerald-400" />
                                    </div>
                                    <div className="flex-1 min-w-0">
                                      <p className="text-[10px] text-white/40">Published at</p>
                                      <p className="text-xs text-white/80 truncate font-mono">
                                        {(publishedUrl || `https://www.replay.build/p/${activeGeneration?.publishedSlug}`).replace('https://www.', '')}
                                      </p>
                                    </div>
                                    <div className="flex gap-1">
                                      <button 
                                        onClick={async () => {
                                          const url = publishedUrl || `https://www.replay.build/p/${activeGeneration?.publishedSlug}`;
                                          await navigator.clipboard.writeText(url);
                                          showToast("URL copied!", "success");
                                        }}
                                        className="p-1.5 hover:bg-white/10 rounded-lg transition-colors"
                                        title="Copy URL"
                                      >
                                        <Copy className="w-3.5 h-3.5 text-white/50" />
                                      </button>
                                      <button 
                                        onClick={() => {
                                          const url = publishedUrl || `https://www.replay.build/p/${activeGeneration?.publishedSlug}`;
                                          window.open(url, "_blank");
                                        }}
                                        className="p-1.5 hover:bg-white/10 rounded-lg transition-colors"
                                        title="Open"
                                      >
                                        <ExternalLink className="w-3.5 h-3.5 text-white/50" />
                                      </button>
                                    </div>
                                  </div>
                                  
                                  <button
                                    onClick={handlePublish}
                                    disabled={isPublishing}
                                    className="w-full py-2.5 bg-[#FF6E3C] hover:bg-[#FF8F5C] text-white text-sm font-semibold rounded-lg transition-colors disabled:opacity-50 flex items-center justify-center gap-2"
                                  >
                                    {isPublishing ? (
                                      <><Loader2 className="w-3.5 h-3.5 animate-spin" /> Updating...</>
                                    ) : (
                                      <><RefreshCw className="w-3.5 h-3.5" /> Update</>
                                    )}
                                  </button>
                                </div>
                              ) : (
                                <div className="space-y-3">
                                  <p className="text-xs text-white/50">
                                    Get a shareable link for your project
                                  </p>
                                  <button
                                    onClick={handlePublish}
                                    disabled={isPublishing}
                                    className="w-full py-2.5 bg-[#FF6E3C] hover:bg-[#FF8F5C] text-white text-sm font-semibold rounded-lg transition-colors disabled:opacity-50 flex items-center justify-center gap-2"
                                  >
                                    {isPublishing ? (
                                      <><Loader2 className="w-3.5 h-3.5 animate-spin" /> Publishing...</>
                                    ) : (
                                      <><ExternalLink className="w-3.5 h-3.5" /> Publish</>
                                    )}
                                  </button>
                                </div>
                              )}
                            </div>
                          </motion.div>
                        </>
                      )}
                    </AnimatePresence>
                  </div>
                </>
              )}
            </div>
          </div>

          <div className="flex-1 overflow-hidden flex flex-col relative">
            {/* Preview - show loading during ANY generation phase, only show iframe when FULLY done */}
            {viewMode === "preview" && (
              <div className="flex-1 preview-container relative bg-[#0a0a0a] flex flex-col">
                {(isProcessing || isStreamingCode) ? (
                  <div className="w-full h-full flex items-center justify-center bg-[#0a0a0a]">
                    <LoadingState />
                  </div>
                ) : previewUrl ? (
                  <>
                    {/* Iframe container */}
                    <div className={cn("flex-1 flex items-center justify-center", isMobilePreview && "py-4 bg-[#0a0a0a]")}>
                      <iframe 
                        key={previewUrl}
                        ref={previewIframeRef}
                        src={previewUrl} 
                        className={cn(
                          "border-0 bg-white transition-all duration-300",
                          isMobilePreview 
                            ? "w-[375px] h-[667px] rounded-3xl shadow-2xl ring-4 ring-black/50" 
                            : "w-full h-full",
                          isPointAndEdit && "cursor-crosshair"
                        )} 
                        title="Preview" 
                        sandbox="allow-scripts allow-same-origin" 
                      />
                    </div>
                    
                    {!showFloatingEdit && (
                      <button onClick={() => setShowFloatingEdit(true)} className="floating-edit-btn flex items-center gap-2 px-5 py-3 rounded-full text-sm font-medium text-white/90">
                        <Sparkles className="w-4 h-4 text-[#FF6E3C]" /> Edit with AI
                      </button>
                    )}
                  </>
                ) : (
                  <div className="w-full h-full flex items-center justify-center bg-[#0a0a0a]">
                    <EmptyState icon="logo" title="Drop or record video. Get code." subtitle="We analyze the flow, map interactions, and export clean code." showEarlyAccess={generations.length === 0} />
                  </div>
                )}
              </div>
            )}

            {/* Code - Professional Code Tab with mode toggle and file tree */}
            {viewMode === "code" && (
              <div className="flex-1 flex flex-col relative bg-[#0a0a0a] min-h-0 overflow-hidden">
                {/* Show loading during generation - hide everything else */}
                {(isProcessing || isStreamingCode) ? (
                  <div className="w-full h-full flex items-center justify-center bg-[#0a0a0a]">
                    <LoadingState />
                  </div>
                ) : (
                  <>
                {/* Code Tab Header - Mode toggle, status, actions */}
                {displayedCode && (
                  <div className="flex-shrink-0 border-b border-white/5 bg-[#0c0c0c] px-3 py-2">
                    <div className="flex items-center justify-between gap-3">
                      {/* Left: Mode toggle - Componentized only after generation complete */}
                      <div className="flex items-center gap-3">
                        <div className="flex items-center bg-black/50 rounded-lg p-0.5">
                          <button
                            onClick={() => setCodeMode("single-file")}
                            className={cn(
                              "px-3 py-1 rounded-md text-[10px] font-medium transition-all",
                              codeMode === "single-file" 
                                ? "bg-white/10 text-white" 
                                : "text-white/40 hover:text-white/60"
                            )}
                          >
                            Single-file
                          </button>
                          <button
                            onClick={() => generationComplete && setCodeMode("componentized")}
                            disabled={!generationComplete}
                            className={cn(
                              "px-3 py-1 rounded-md text-[10px] font-medium transition-all",
                              !generationComplete && "opacity-50 cursor-not-allowed",
                              codeMode === "componentized" 
                                ? "bg-white/10 text-white" 
                                : "text-white/40 hover:text-white/60"
                            )}
                            title={!generationComplete ? "Complete generation first" : ""}
                          >
                            Componentized
                          </button>
                        </div>
                      </div>
                      
                      {/* Right: Actions */}
                      <div className="flex items-center gap-1.5">
                        <button 
                          onClick={() => {
                            const content = getActiveFileContent();
                            navigator.clipboard.writeText(content);
                            showToast("Code copied to clipboard", "success");
                          }}
                          className="flex items-center gap-1 px-2 py-1 rounded text-[10px] text-white/40 hover:text-white/60 hover:bg-white/5 transition-colors"
                        >
                          <Copy className="w-3 h-3" />
                          <span>Copy</span>
                        </button>
                        <button 
                          onClick={handleDownload}
                          className="flex items-center gap-1 px-2 py-1 rounded text-[10px] text-white/40 hover:text-white/60 hover:bg-white/5 transition-colors"
                        >
                          <Download className="w-3 h-3" />
                          <span>Download</span>
                        </button>
                      </div>
                    </div>
                  </div>
                )}
                
                {/* Main Code Area */}
                <div className="flex-1 flex min-h-0 overflow-hidden">
                  {/* File Tree Panel - Same width for both modes */}
                  {displayedCode && (
                    <div className="w-56 flex-shrink-0 border-r border-white/5 overflow-y-auto bg-[#080808]">
                      <div className="p-2 border-b border-white/5 sticky top-0 bg-[#080808] z-10">
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-1.5 text-[9px] text-white/40 uppercase tracking-wider">
                            <FolderTree className="w-3 h-3" />
                            <span>Files</span>
                          </div>
                          <span className="text-[8px] text-white/20">{generatedFiles.length} files</span>
                        </div>
                      </div>
                      
                      <div className="p-1 text-[10px]">
                        {/* Render file tree */}
                        {buildFileTree(generatedFiles).map((item) => (
                          <FileTreeItem 
                            key={item.path} 
                            item={item} 
                            activeFilePath={activeFilePath}
                            onFileClick={(path, isStub, nodeId) => {
                              if (isStub && nodeId) {
                                // For stubs, only fill the edit input - DON'T start generating yet
                                // Generation only starts when user clicks the send button
                                // Block if currently editing
                                if (isEditing) return;
                                const node = flowNodes.find(n => n.id === nodeId);
                                if (node) {
                                  setEditInput(`@${node.name} Create this page with full content and layout`);
                                  setShowFloatingEdit(true);
                                  // Focus the edit input
                                  setTimeout(() => editInputRef.current?.focus(), 100);
                                }
                              } else {
                                setActiveFilePath(path);
                              }
                            }}
                            onFolderToggle={toggleFolder}
                            expandedFolders={expandedFolders}
                            generatingPath={generatingFilePath}
                          />
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Code Editor Panel */}
                  <div className="flex-1 flex flex-col min-w-0 overflow-hidden">
                    {/* Breadcrumb bar */}
                    {displayedCode && (
                      <div className="flex-shrink-0 px-3 py-1.5 border-b border-white/5 bg-[#0a0a0a] flex items-center gap-2">
                        <span className="text-[10px] text-white/30">
                          {activeFilePath.split('/').filter(Boolean).map((part, i, arr) => (
                            <span key={i}>
                              <span className={i === arr.length - 1 ? "text-white/60" : ""}>{part}</span>
                              {i < arr.length - 1 && <span className="mx-1 text-white/20">/</span>}
                            </span>
                          ))}
                        </span>
                        {generatedFiles.find(f => f.path === activeFilePath)?.isStub && (
                          <span className="px-1.5 py-0.5 rounded text-[8px] bg-yellow-500/10 text-yellow-400/70 border border-yellow-500/20">
                            STUB
                          </span>
                        )}
                        {generatedFiles.find(f => f.path === activeFilePath)?.lineCount && (
                          <span className="ml-auto text-[9px] text-white/20">
                            {generatedFiles.find(f => f.path === activeFilePath)?.lineCount} lines
                          </span>
                        )}
                      </div>
                    )}
                    
                    {/* Code content */}
                    <div ref={codeContainerRef} className="flex-1 overflow-auto">
                      {isCodeEditable ? (
                        <textarea 
                          value={editableCode} 
                          onChange={(e) => setEditableCode(e.target.value)} 
                          className="w-full h-full p-3 bg-[#0a0a0a] text-[11px] text-white/80 font-mono resize-none focus:outline-none" 
                          style={{ fontFamily: "'JetBrains Mono', monospace" }} 
                          spellCheck={false} 
                        />
                      ) : generatingFilePath && generatingFilePath === activeFilePath ? (
                        // Show loading state when generating the currently viewed file
                        <div className="w-full h-full flex flex-col items-center justify-center bg-[#0a0a0a] gap-4">
                          <Loader2 className="w-8 h-8 text-[#FF6E3C] animate-spin" />
                          <div className="text-center">
                            <p className="text-sm text-white/60 font-medium">Generating page...</p>
                            <p className="text-xs text-white/30 mt-1">{activeFilePath.split('/').pop()}</p>
                          </div>
                        </div>
                      ) : displayedCode ? (
                        <div className="overflow-x-auto">
                          <Highlight 
                            theme={themes.nightOwl} 
                            code={getActiveFileContent()} 
                            language={activeFilePath.endsWith('.tsx') || activeFilePath.endsWith('.ts') ? 'tsx' : 'html'}
                          >
                            {({ style, tokens, getLineProps, getTokenProps }) => (
                              <pre 
                                className="p-3 text-[11px] leading-relaxed" 
                                style={{ 
                                  ...style, 
                                  background: "#0a0a0a", 
                                  fontFamily: "'JetBrains Mono', monospace", 
                                  minHeight: "100%",
                                  minWidth: "fit-content"
                                }}
                              >
                                {tokens.map((line, i) => {
                                  const lineNum = i + 1;
                                  const isHighlighted = highlightedLines && lineNum >= highlightedLines.start && lineNum <= highlightedLines.end;
                                  return (
                                    <div 
                                      key={i} 
                                      {...getLineProps({ line })}
                                      className={cn(
                                        isHighlighted && "bg-[#FF6E3C]/10 -mx-3 px-3 border-l-2 border-[#FF6E3C]"
                                      )}
                                    >
                                      <span className="inline-block w-8 pr-3 text-right text-white/15 select-none text-[10px]">{lineNum}</span>
                                      {line.map((token, key) => <span key={key} {...getTokenProps({ token })} />)}
                                    </div>
                                  );
                                })}
                                {isStreamingCode && <span className="text-[#FF6E3C] animate-pulse"></span>}
                              </pre>
                            )}
                          </Highlight>
                        </div>
                      ) : (
                        <div className="w-full h-full flex items-center justify-center bg-[#0a0a0a]">
                          {isProcessing ? <LoadingState /> : <EmptyState icon="logo" title="No code generated" subtitle="Generate from a video to see the code" />}
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {/* Inspector Panel removed - simplified UI */}
                </div>
                
                {editableCode && !isStreamingCode && !isCodeEditable && !showFloatingEdit && (
                  <button onClick={() => setShowFloatingEdit(true)} className="floating-edit-btn flex items-center gap-2 px-5 py-3 rounded-full text-sm font-medium text-white/90">
                    <Sparkles className="w-4 h-4 text-[#FF6E3C]" /> Edit with AI
                  </button>
                )}
                  </>
                )}
              </div>
            )}

            {/* Flow - PRODUCT MAP (Canvas) - what's possible, not what happened */}
            {viewMode === "flow" && (
              <div className="flex-1 overflow-hidden bg-[#080808] relative flex flex-col">
                {/* Show loader when processing (same as other views) */}
                {(isProcessing || isStreamingCode) ? (
                  <div className="w-full h-full flex items-center justify-center bg-[#080808]">
                    <LoadingState />
                  </div>
                ) : flowNodes.length > 0 || flowBuilding ? (
                  <>
                    {/* Toggle buttons - top right */}
                    <div className="absolute top-4 right-4 z-20 flex items-center gap-2">
                      {/* Possible paths toggle */}
                      <button 
                        onClick={() => setShowPossiblePaths(!showPossiblePaths)}
                        className={cn(
                          "flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium transition-all shadow-lg",
                          showPossiblePaths 
                            ? "bg-white/10 border border-white/20 text-white/80" 
                            : "bg-[#1a1a1a] border border-white/10 text-white/40 hover:border-white/20"
                        )}
                      >
                        <GitBranch className="w-3.5 h-3.5" />
                        Possible
                      </button>
                      {/* Structure toggle */}
                      <button 
                        onClick={() => setShowStructureInFlow(!showStructureInFlow)}
                        className={cn(
                          "flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium transition-all shadow-lg",
                          showStructureInFlow 
                            ? "bg-[#FF6E3C] text-white" 
                            : "bg-[#1a1a1a] border border-white/10 text-white/60 hover:border-white/20"
                        )}
                      >
                        <Layers className="w-3.5 h-3.5" />
                        Structure
                      </button>
                    </div>
                    
                    {/* Node Detail Panel removed - simplified UI */}
                    
                    
                    <div 
                      ref={archCanvasRef}
                      className={cn("arch-canvas w-full h-full", isPanning && !draggingNodeId && "dragging")}
                      onMouseDown={(e) => {
                        if (!draggingNodeId) handleCanvasMouseDown(e);
                      }}
                      onMouseMove={(e) => {
                        if (draggingNodeId) {
                          // Dragging a node
                          const dx = (e.clientX - dragStartPos.current.x) / archZoom;
                          const dy = (e.clientY - dragStartPos.current.y) / archZoom;
                          setFlowNodes(prev => prev.map(n => 
                            n.id === draggingNodeId 
                              ? { ...n, x: dragStartPos.current.nodeX + dx, y: dragStartPos.current.nodeY + dy }
                              : n
                          ));
                        } else {
                          handleCanvasMouseMove(e);
                        }
                      }}
                      onMouseUp={() => {
                        if (draggingNodeId) {
                          setDraggingNodeId(null);
                        } else {
                          handleCanvasMouseUp();
                        }
                      }}
                      onMouseLeave={() => {
                        setDraggingNodeId(null);
                        handleCanvasMouseUp();
                      }}
                    >
                      <div 
                        className="arch-canvas-inner" 
                        style={{ 
                          transform: `translate(${canvasPan.x}px, ${canvasPan.y}px) scale(${archZoom})`,
                          transformOrigin: 'center center'
                        }}
                      >
                        {/* Edge lines with semantic styling - Full coverage SVG */}
                        <svg 
                          className="absolute pointer-events-none" 
                          style={{ left: 0, top: 0, width: "20000px", height: "12000px" }}
                        >
                          <defs>
                            <marker id="flow-arrow" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                              <polygon points="0 0, 8 3, 0 6" fill="rgba(255, 255, 255, 0.5)" />
                            </marker>
                            <marker id="flow-arrow-thick" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                              <polygon points="0 0, 10 3.5, 0 7" fill="rgba(255, 255, 255, 0.6)" />
                            </marker>
                            <marker id="flow-arrow-gated" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                              <polygon points="0 0, 8 3, 0 6" fill="rgba(255, 255, 255, 0.4)" />
                            </marker>
                          </defs>
                          {flowEdges
                            .filter(edge => showPossiblePaths || edge.type !== "possible")
                            .map(edge => {
                            const fromNode = flowNodes.find(n => n.id === edge.from);
                            const toNode = flowNodes.find(n => n.id === edge.to);
                            if (!fromNode || !toNode) return null;
                            // Hide edges to hidden detected/possible nodes
                            if (!showPossiblePaths && (toNode.status === "detected" || toNode.status === "possible")) return null;
                            const x1 = fromNode.x + 90;
                            const y1 = fromNode.y + (showStructureInFlow ? 100 : 60);
                            const x2 = toNode.x + 90;
                            const y2 = toNode.y;
                            const midX = (x1 + x2) / 2;
                            const midY = (y1 + y2) / 2;
                            
                            // Edge styles: implemented = solid, possible = dashed gray
                            const edgeStyles: Record<string, { stroke: string; width: number; dash?: string; marker: string; labelBg: string }> = {
                              navigation: { stroke: "rgba(255, 255, 255, 0.4)", width: 2, marker: "url(#flow-arrow-thick)", labelBg: "rgba(10, 10, 10, 0.9)" },
                              action: { stroke: "rgba(255, 255, 255, 0.35)", width: 1.5, marker: "url(#flow-arrow)", labelBg: "rgba(10, 10, 10, 0.9)" },
                              scroll: { stroke: "rgba(255, 255, 255, 0.25)", width: 1.5, marker: "url(#flow-arrow)", labelBg: "rgba(10, 10, 10, 0.9)" },
                              gated: { stroke: "rgba(255, 255, 255, 0.3)", width: 1.5, dash: "5 3", marker: "url(#flow-arrow-gated)", labelBg: "rgba(10, 10, 10, 0.9)" },
                              possible: { stroke: "rgba(255, 255, 255, 0.12)", width: 1, dash: "4 4", marker: "url(#flow-arrow-gated)", labelBg: "rgba(20, 20, 20, 0.8)" }
                            };
                            const style = edgeStyles[edge.type] || edgeStyles.action;
                            const isPossible = edge.type === "possible";
                            
                            return (
                              <g key={edge.id} className={isPossible ? "opacity-60" : ""}>
                                <path 
                                  d={`M ${x1} ${y1} Q ${x1} ${midY} ${midX} ${midY} Q ${x2} ${midY} ${x2} ${y2}`}
                                  stroke={style.stroke}
                                  strokeWidth={style.width}
                                  strokeDasharray={style.dash}
                                  fill="none"
                                  markerEnd={style.marker}
                                />
                                {/* Label */}
                                <rect 
                                  x={midX - 45} 
                                  y={midY - 9} 
                                  width="90" 
                                  height="18" 
                                  rx="9" 
                                  fill={style.labelBg}
                                  stroke={isPossible ? "rgba(255, 255, 255, 0.05)" : "rgba(255, 255, 255, 0.1)"}
                                  strokeWidth="1"
                                  strokeDasharray={isPossible ? "3 2" : undefined}
                                />
                                {edge.type === "gated" && (
                                  <text x={midX - 32} y={midY + 3} fill="rgba(255, 255, 255, 0.4)" fontSize="9"></text>
                                )}
                                {isPossible && (
                                  <text x={midX - 32} y={midY + 3} fill="rgba(255, 255, 255, 0.25)" fontSize="8"></text>
                                )}
                                <text 
                                  x={edge.type === "gated" || isPossible ? midX + 4 : midX} 
                                  y={midY + 3} 
                                  fill={isPossible ? "rgba(255,255,255,0.3)" : "rgba(255,255,255,0.5)"} 
                                  fontSize="9" 
                                  textAnchor="middle" 
                                  className="font-medium"
                                  fontStyle={isPossible ? "italic" : "normal"}
                                >
                                  {edge.label}
                                </text>
                              </g>
                            );
                          })}
                        </svg>
                        
                        {/* Flow Nodes - Draggable */}
                        {flowNodes
                          .filter(node => showPossiblePaths || node.status === "observed" || node.status === "added")
                          .map((node, idx) => {
                          const isObserved = node.status === "observed";
                          const isDetected = node.status === "detected";
                          const isPossible = node.status === "possible";
                          const isAdded = node.status === "added";
                          const typeIcons: Record<string, any> = { view: Layout, section: Layers, modal: Box, state: CheckCircle };
                          const Icon = typeIcons[node.type] || Layout;
                          const isDragging = draggingNodeId === node.id;
                          
                          // Confidence-based styling - "added" looks like "observed" (green) since they're active
                          const confidenceStyles: Record<string, string> = {
                            observed: "border-solid border-emerald-500/40 bg-[#0a0a0a]",
                            detected: "border-solid border-amber-500/30 bg-[#0a0a0a]",
                            possible: "border-dashed border-white/20 bg-[#0a0a0a]/50",
                            added: "border-solid border-emerald-500/40 bg-[#0a0a0a]"
                          };
                          
                          return (
                            <div 
                              key={node.id}
                              className={cn(
                                "absolute w-44 rounded-xl border backdrop-blur-sm select-none",
                                confidenceStyles[node.status] || confidenceStyles.detected,
                                selectedFlowNode === node.id && "ring-1 ring-[#FF6E3C]/50 border-[#FF6E3C]/30",
                                isDragging ? "cursor-grabbing shadow-2xl z-50 scale-[1.02]" : "hover:border-white/30"
                              )}
                              style={{ 
                                left: node.x, 
                                top: node.y,
                                transition: isDragging ? 'none' : 'border-color 0.15s, box-shadow 0.15s',
                                opacity: isPossible ? 0.6 : isDetected ? 0.8 : 1
                              }}
                              title={isObserved ? "Shown and confirmed in the video recording" : isDetected ? "Present in navigation, but not shown in video" : "Reachable from observed paths, not yet confirmed"}
                            >
                              {/* Node header - DRAGGABLE */}
                              <div 
                                className={cn(
                                  "p-3 border-b cursor-grab active:cursor-grabbing",
                                  isPossible ? "border-white/5 border-dashed" : "border-white/5",
                                  draggingNodeId === node.id && "cursor-grabbing"
                                )}
                                onMouseDown={(e) => {
                                  e.stopPropagation();
                                  setDraggingNodeId(node.id);
                                  dragStartPos.current = { 
                                    x: e.clientX, 
                                    y: e.clientY, 
                                    nodeX: node.x, 
                                    nodeY: node.y 
                                  };
                                }}
                                onClick={(e) => {
                                  if (!draggingNodeId) {
                                    setSelectedFlowNode(node.id === selectedFlowNode ? null : node.id);
                                    // For detected/possible nodes, open edit with @NodeName prefilled
                                    // Only if not currently editing
                                    if ((isDetected || isPossible) && node.id !== "home" && !isEditing) {
                                      setEditInput(`@${node.name} `);
                                      setShowFloatingEdit(true);
                                    }
                                  }
                                }}
                                onDoubleClick={(e) => {
                                  e.stopPropagation();
                                  // Double-click to view code for this node
                                  handleFlowNodeCodeFocus(node.id);
                                }}
                              >
                                <div className="flex items-center gap-2">
                                  {/* Confidence indicator */}
                                  {isObserved && <div className="w-1.5 h-1.5 rounded-full bg-emerald-400 flex-shrink-0" title="Observed" />}
                                  {isDetected && <div className="w-1.5 h-1.5 rounded-full bg-amber-400 flex-shrink-0" title="Detected" />}
                                  {isPossible && <div className="w-1.5 h-1.5 rounded-full bg-white/40 flex-shrink-0" title="Possible" />}
                                  <Icon className={cn("w-4 h-4 flex-shrink-0", 
                                    isObserved ? "text-emerald-400" : isDetected ? "text-amber-400" : "text-white/40"
                                  )} />
                                  <span className={cn(
                                    "text-sm font-semibold truncate", 
                                    isPossible ? "text-white/50 italic" : isDetected ? "text-white/70" : "text-white/90"
                                  )} title={node.name}>{node.name}</span>
                                </div>
                                {node.description && (
                                  <p className={cn("text-[10px] mt-1 line-clamp-2", isPossible ? "text-white/25" : isDetected ? "text-white/30" : "text-white/40")}>{node.description}</p>
                                )}
                              </div>
                              
                              {/* Structure overlay (when toggle is ON) */}
                              <AnimatePresence>
                                {showStructureInFlow && node.components && node.components.length > 0 && (
                                  <motion.div 
                                    initial={{ height: 0, opacity: 0 }}
                                    animate={{ height: "auto", opacity: 1 }}
                                    exit={{ height: 0, opacity: 0 }}
                                    className="overflow-hidden"
                                  >
                                    <div className="p-2 bg-white/[0.02]">
                                      <div className="flex items-center gap-1.5 mb-1.5">
                                        <GitBranch className="w-3 h-3 text-white/30" />
                                        <span className="text-[9px] text-white/30 uppercase tracking-wider">Components</span>
                                      </div>
                                      <div className="space-y-1">
                                        {node.components.map((comp, i) => (
                                          <div key={i} className="flex items-center gap-1.5 text-[10px] text-white/50">
                                            <div className="w-1 h-1 rounded-full bg-[#FF6E3C]/50" />
                                            {comp}
                                          </div>
                                        ))}
                                      </div>
                                    </div>
                                  </motion.div>
                                )}
                              </AnimatePresence>
                              
                              {/* Action buttons - CTAs based on status */}
                              <div className="flex items-center gap-1 p-2 border-t border-white/5">
                                {(isObserved || isAdded) ? (
                                  <button
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      handleFlowNodeCodeFocus(node.id);
                                    }}
                                    className="flex-1 flex items-center justify-center gap-1 py-1.5 rounded text-[9px] bg-white/5 hover:bg-white/10 text-white/50 hover:text-white/70 transition-colors"
                                  >
                                    <Code className="w-3 h-3" />
                                    View Code
                                  </button>
                                ) : isDetected ? (
                                  <button
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      if (isEditing) return;
                                      setEditInput(`@${node.name} Reconstruct this page based on observed navigation patterns and styling from the main page`);
                                      setShowFloatingEdit(true);
                                    }}
                                    disabled={isEditing}
                                    className="flex-1 flex items-center justify-center gap-1 py-1.5 rounded text-[9px] bg-amber-500/20 hover:bg-amber-500/30 text-amber-400/80 hover:text-amber-400 transition-colors disabled:opacity-50"
                                    title="Reconstruct from observed patterns"
                                  >
                                    <Plus className="w-3 h-3" />
                                    Reconstruct
                                  </button>
                                ) : (
                                  <button
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      if (isEditing) return;
                                      setEditInput(`@${node.name} Generate this flow continuation with consistent style and navigation`);
                                      setShowFloatingEdit(true);
                                    }}
                                    disabled={isEditing}
                                    className="flex-1 flex items-center justify-center gap-1 py-1.5 rounded text-[9px] bg-white/10 hover:bg-white/15 text-white/50 hover:text-white/70 transition-colors disabled:opacity-50"
                                    title="Generate flow continuation"
                                  >
                                    <Plus className="w-3 h-3" />
                                    Generate
                                  </button>
                                )}
                              </div>
                              
                              {/* Status badge */}
                              <div className="absolute -top-2 -right-2">
                                <span className={cn(
                                  "text-[8px] px-1.5 py-0.5 rounded-full bg-[#0a0a0a] border capitalize",
                                  isObserved 
                                    ? "border-emerald-500/30 text-emerald-400/70" 
                                    : isAdded
                                    ? "border-emerald-500/30 text-emerald-400/70"
                                    : isDetected
                                    ? "border-amber-500/30 text-amber-400/70"
                                    : "border-dashed border-white/10 text-white/30 italic"
                                )}>
                                  {isObserved ? "observed" : isAdded ? "added" : isDetected ? "detected" : "possible"}
                                </span>
                              </div>
                            </div>
                          );
                        })}
                        
                        
                        {flowBuilding && (
                          <div className="absolute top-4 left-4 flex items-center gap-2 text-xs text-white/40 bg-black/50 px-3 py-2 rounded-lg">
                            <Loader2 className="w-4 h-4 animate-spin text-[#FF6E3C]" />
                            Building product map...
                          </div>
                        )}
                      </div>
                    </div>
                  </>
                ) : (
                  <div className="w-full h-full flex items-center justify-center bg-[#080808]">
                    <div className="text-center">
                      <GitBranch className="w-10 h-10 text-white/10 mx-auto mb-3" />
                      <p className="text-sm text-white/40">No product flow yet</p>
                      <p className="text-xs text-white/25 mt-1">Flow shows how the product is connected - views, states, transitions</p>
                    </div>
                  </div>
                )}
                
                {/* Edit with AI button for Flow */}
                {!flowBuilding && flowNodes.length > 0 && !showFloatingEdit && !isProcessing && (
                  <button 
                    onClick={() => setShowFloatingEdit(true)} 
                    className="floating-edit-btn flex items-center gap-2 px-5 py-3 rounded-full text-sm font-medium text-white/90"
                  >
                    <Sparkles className="w-4 h-4 text-[#FF6E3C]" /> Edit with AI
                  </button>
                )}
              </div>
            )}
            

            {/* Design System */}
            {viewMode === "design" && (
              <div className="flex-1 overflow-auto p-6 bg-[#080808] relative">
                {(isProcessing || isStreamingCode) ? (
                  <div className="w-full h-full flex items-center justify-center bg-[#080808]">
                    <LoadingState />
                  </div>
                ) : styleInfo ? (
                  <div className="max-w-3xl mx-auto space-y-6">
                    <div className="flex items-center gap-2 mb-6"><Paintbrush className="w-5 h-5 text-[#FF6E3C]/60" /><h3 className="text-sm font-medium text-white/70">Design System</h3></div>
                    
                    {/* Colors with usage badges */}
                    <div className="style-card">
                      <div className="flex items-center gap-2 mb-4"><Droplet className="w-4 h-4 text-[#FF6E3C]/60" /><span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Colors</span></div>
                      <div className="space-y-4">
                        {styleInfo.colors.map((color, i) => {
                          // Generate usage hints based on color role
                          const usageHints: Record<string, string> = {
                            "Primary": "Used in: Primary CTAs, Active states, Links",
                            "Secondary": "Used in: Secondary buttons, Borders, Icons",
                            "Accent": "Used in: Highlights, Badges, Alerts",
                            "Background": "Used in: Page background, Cards",
                            "Text": "Used in: Body text, Headings",
                            "Border": "Used in: Dividers, Input borders"
                          };
                          return (
                            <div key={i} className="flex items-start gap-3">
                              <div className="color-swatch-large flex-shrink-0" style={{ backgroundColor: color.value }} />
                              <div className="flex-1 min-w-0">
                                <div className="flex items-center gap-2">
                                  <p className="text-xs text-white/70">{color.name}</p>
                                  <p className="text-[10px] text-white/40 font-mono">{color.value}</p>
                                </div>
                                <p className="text-[9px] text-white/30 mt-1">{usageHints[color.name] || "Used in: UI elements"}</p>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                    
                    {/* Typography with usage badges */}
                    <div className="style-card">
                      <div className="flex items-center gap-2 mb-4"><Type className="w-4 h-4 text-[#FF6E3C]/60" /><span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Typography</span></div>
                      <div className="space-y-4">
                        {styleInfo.fonts.map((font, i) => {
                          const fontUsageHints = [
                            "Used in: Headers (H1H3), Hero titles, CTAs",
                            "Used in: Body text, Paragraphs, Forms",
                            "Used in: Labels, Captions, Meta info",
                            "Used in: Code blocks, Data displays"
                          ];
                          return (
                            <div key={i} className="font-preview">
                              <div className="flex items-center justify-between">
                                <div>
                                  <p className="text-lg text-white/80" style={{ fontFamily: font.family }}>{font.name}</p>
                                  <p className="text-[10px] text-white/40">{font.usage}</p>
                                </div>
                                <div className="text-right">
                                  <span className="text-xs text-white/30">{font.weight}</span>
                                  <p className="text-[10px] text-white/20 font-mono mt-1">{font.family}</p>
                                </div>
                              </div>
                              <p className="text-[9px] text-white/30 mt-1 pt-1 border-t border-white/5">{fontUsageHints[i] || "Used in: Various UI elements"}</p>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                    
                    {/* Other Styles */}
                    <div className="grid grid-cols-3 gap-4">
                      <div className="style-card"><p className="text-[10px] text-white/40 uppercase mb-2">Spacing</p><p className="text-sm text-white/70">{styleInfo.spacing}</p></div>
                      <div className="style-card"><p className="text-[10px] text-white/40 uppercase mb-2">Border Radius</p><p className="text-sm text-white/70">{styleInfo.borderRadius}</p></div>
                      <div className="style-card"><p className="text-[10px] text-white/40 uppercase mb-2">Shadows</p><p className="text-sm text-white/70">{styleInfo.shadows}</p></div>
                    </div>
                    
                    {!showFloatingEdit && (
                      <button onClick={() => setShowFloatingEdit(true)} className="floating-edit-btn flex items-center gap-2 px-5 py-3 rounded-full text-sm font-medium text-white/90">
                        <Sparkles className="w-4 h-4 text-[#FF6E3C]" /> Edit with AI
                      </button>
                    )}
                  </div>
                ) : (
                  <div className="w-full h-full flex items-center justify-center bg-[#080808]">
                    <EmptyState icon="logo" title="No style info yet" subtitle="Generate code to see the design system" />
                  </div>
                )}
              </div>
            )}

            {/* Input - Custom Video Player with better trim */}
            {viewMode === "input" && (
              <div className="flex-1 bg-[#0a0a0a] flex flex-col overflow-hidden">
                {selectedFlow ? (
                  <>
                    <div className="flex-1 flex items-center justify-center p-4 min-h-0 bg-black">
                      <video 
                        ref={videoRef} 
                        src={selectedFlow.videoUrl} 
                        className="max-w-full max-h-full rounded-lg" 
                        onPlay={() => setIsPlaying(true)} 
                        onPause={() => setIsPlaying(false)}
                        onLoadedMetadata={(e) => {
                          const video = e.currentTarget;
                          if (video.duration && isFinite(video.duration) && video.duration > 0) {
                            const newDuration = Math.round(video.duration);
                            // Update flow duration if it was invalid
                            if (!selectedFlow.duration || !isFinite(selectedFlow.duration) || selectedFlow.duration <= 0) {
                              setFlows(prev => prev.map(f => 
                                f.id === selectedFlow.id 
                                  ? { ...f, duration: newDuration, trimEnd: newDuration }
                                  : f
                              ));
                            }
                          }
                        }}
                        onTimeUpdate={(e) => setCurrentTime(e.currentTarget.currentTime)}
                      />
                    </div>
                    <div className="p-4 border-t border-white/5 bg-[#0a0a0a]">
                      {/* Playback controls */}
                      <div className="flex items-center gap-3 mb-4">
                        <button onClick={togglePlayPause} className="btn-black p-2.5 rounded-lg">
                          {isPlaying ? <Pause className="w-4 h-4" /> : <Play className="w-4 h-4" />}
                        </button>
                        <span className="text-xs text-white/50 font-mono w-24">{formatDuration(Math.floor(currentTime))} / {formatDuration(selectedFlow.duration)}</span>
                      </div>
                      
                      {/* Trim bar with live preview */}
                      <div className="mb-4">
                        <div className="flex items-center justify-between text-xs text-white/40 mb-2">
                          <span>Trim selection</span>
                          <span className="font-mono">{formatDuration(selectedFlow.trimStart)} - {formatDuration(selectedFlow.trimEnd)}</span>
                        </div>
                        <div 
                          ref={trimBarRef} 
                          className="trim-slider-container relative cursor-pointer"
                          onClick={(e) => {
                            // Click to seek - only if not clicking on handles
                            if ((e.target as HTMLElement).classList.contains('trim-handle')) return;
                            const rect = trimBarRef.current?.getBoundingClientRect();
                            if (!rect || !videoRef.current || !selectedFlow || !selectedFlow.duration || selectedFlow.duration <= 0) return;
                            const x = e.clientX - rect.left;
                            const percent = Math.max(0, Math.min(1, x / rect.width));
                            const time = percent * selectedFlow.duration;
                            if (isFinite(time) && time >= 0 && time <= selectedFlow.duration) {
                              videoRef.current.currentTime = time;
                              setCurrentTime(time);
                            }
                          }}
                        >
                          <div className="trim-waveform" />
                          {/* Selected area */}
                          {selectedFlow.duration > 0 && isFinite(selectedFlow.duration) && (
                            <>
                              <div className="trim-selected-area" style={{
                                left: `${Math.max(0, (selectedFlow.trimStart / selectedFlow.duration) * 100)}%`,
                                width: `${Math.max(0, ((selectedFlow.trimEnd - selectedFlow.trimStart) / selectedFlow.duration) * 100)}%`
                              }} />
                              {/* Start handle with tooltip */}
                              <div 
                                className="trim-handle" 
                                style={{ left: `calc(${Math.max(0, (selectedFlow.trimStart / selectedFlow.duration) * 100)}% - 7px)` }}
                                onMouseDown={(e) => { e.stopPropagation(); handleTrimDrag(e, "start"); }} 
                              >
                                {isDraggingTrim === "start" && trimPreviewTime !== null && (
                                  <div className="trim-time-tooltip">{formatDuration(trimPreviewTime)}</div>
                                )}
                              </div>
                              {/* End handle with tooltip */}
                              <div 
                                className="trim-handle" 
                                style={{ left: `calc(${Math.min(100, (selectedFlow.trimEnd / selectedFlow.duration) * 100)}% - 7px)` }}
                                onMouseDown={(e) => { e.stopPropagation(); handleTrimDrag(e, "end"); }} 
                              >
                                {isDraggingTrim === "end" && trimPreviewTime !== null && (
                                  <div className="trim-time-tooltip">{formatDuration(trimPreviewTime)}</div>
                                )}
                              </div>
                              {/* Playhead */}
                              <div className="trim-playhead" style={{ left: `${Math.min(100, (currentTime / selectedFlow.duration) * 100)}%` }} />
                            </>
                          )}
                        </div>
                      </div>
                      
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <button onClick={() => fileInputRef.current?.click()} className="btn-black flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs"><Upload className="w-3.5 h-3.5" /> Upload New</button>
                          <button onClick={startRecording} className="btn-black flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs"><Monitor className="w-3.5 h-3.5" /> Record New</button>
                        </div>
                        <button onClick={applyTrim} className="btn-black flex items-center gap-1.5 px-4 py-1.5 rounded-lg text-xs bg-[#FF6E3C]/20 text-[#FF6E3C] border border-[#FF6E3C]/30">
                          <Check className="w-3.5 h-3.5" /> Apply Trim
                        </button>
                      </div>
                    </div>
                  </>
                ) : (
                  <div className="flex-1 flex items-center justify-center bg-[#0a0a0a]">
                    <div className="text-center">
                      <EmptyState icon="logo" title="No video selected" subtitle="Record or upload a video first" showEarlyAccess={generations.length === 0} />
                      <div className="flex items-center justify-center gap-2 mt-4">
                        <button onClick={() => fileInputRef.current?.click()} className="btn-black flex items-center gap-1.5 px-3 py-2 rounded-lg text-xs"><Upload className="w-3.5 h-3.5" /> Upload</button>
                        <button onClick={startRecording} className="btn-black flex items-center gap-1.5 px-3 py-2 rounded-lg text-xs"><Monitor className="w-3.5 h-3.5" /> Record</button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Global Floating Edit - Properly Centered */}
            <AnimatePresence>
              {showFloatingEdit && (
                <motion.div 
                  initial={{ opacity: 0, y: 20 }} 
                  animate={{ opacity: 1, y: 0 }} 
                  exit={{ opacity: 0, y: 20 }} 
                  className="absolute bottom-6 left-0 right-0 flex justify-center z-50 px-6"
                >
                  <div className="w-full max-w-[500px] backdrop-blur-xl bg-[#0a0a0a]/95 border border-white/[0.04] rounded-2xl p-3 shadow-2xl">
                    <div className="flex items-center gap-2 mb-2">
                      {isEditing ? (
                        <Loader2 className="w-3.5 h-3.5 text-[#FF6E3C] animate-spin" />
                      ) : (
                        <Sparkles className="w-3.5 h-3.5 text-[#FF6E3C]" />
                      )}
                      <span className="text-xs text-white/50">
                        {isEditing ? (
                          <span className="text-[#FF6E3C]/80 animate-pulse">
                            {selectedElement ? `Editing ${selectedElement.substring(0, 20)}...` : editInput.includes('@') ? `Creating ${editInput.match(/@([a-zA-Z0-9-_]+)/)?.[1] || 'page'}...` : 'Applying changes...'}
                          </span>
                        ) : selectedArchNode ? (
                          <>Editing <span className="at-tag">@{selectedArchNode}</span></>
                        ) : "Describe your changes"}
                      </span>
                      {!isEditing && (
                        <button onClick={() => { setShowFloatingEdit(false); setSelectedArchNode(null); setShowSuggestions(false); }} className="ml-auto p-1 hover:bg-white/5 rounded">
                          <X className="w-3 h-3 text-white/20" />
                        </button>
                      )}
                    </div>
                    <div className="relative">
                      {/* Image previews */}
                      {editImages.length > 0 && (
                        <div className="flex flex-wrap gap-2 mb-2">
                          {editImages.map(img => (
                            <div key={img.id} className="relative group">
                              <img src={img.url} alt={img.name} className="w-12 h-12 object-cover rounded-lg border border-white/10" />
                              <button 
                                onClick={() => {
                                  URL.revokeObjectURL(img.url);
                                  setEditImages(prev => prev.filter(i => i.id !== img.id));
                                }}
                                className="absolute -top-1.5 -right-1.5 w-4 h-4 bg-red-500 rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
                              >
                                <X className="w-2.5 h-2.5 text-white" />
                              </button>
                            </div>
                          ))}
                        </div>
                      )}
                      <div className="flex gap-2">
                        {/* Pointer tool button */}
                        <button
                          onClick={() => {
                            const newState = !isPointAndEdit;
                            setIsPointAndEdit(newState);
                            // Clear selected element when turning off pointer
                            if (!newState) {
                              setSelectedElement(null);
                            }
                          }}
                          className={cn(
                            "relative flex items-center justify-center w-10 h-10 rounded-lg border transition-all",
                            isPointAndEdit 
                              ? "bg-[#FF6E3C]/20 border-[#FF6E3C] text-[#FF6E3C] shadow-[0_0_10px_rgba(255,110,60,0.3)]" 
                              : "bg-white/[0.03] border-white/[0.04] hover:border-white/10 text-white/40"
                          )}
                          title={isPointAndEdit ? "Click to deactivate pointer" : "Click element in preview to edit"}
                        >
                          <MousePointer className={cn("w-4 h-4", isPointAndEdit && "animate-pulse")} />
                          {isPointAndEdit && (
                            <span className="absolute -top-1 -right-1 w-2.5 h-2.5 bg-[#FF6E3C] rounded-full animate-pulse" />
                          )}
                        </button>
                        {/* Image upload button */}
                        <label className="flex items-center justify-center w-10 h-10 rounded-lg bg-white/[0.03] border border-white/[0.04] hover:border-white/10 cursor-pointer transition-colors">
                          <input 
                            type="file"
                            accept="image/*"
                            multiple
                            className="hidden"
                            onChange={async (e) => {
                              const files = e.target.files;
                              if (files) {
                                for (const file of Array.from(files)) {
                                  const id = `img_${Date.now()}_${Math.random().toString(36).slice(2)}`;
                                  const localUrl = URL.createObjectURL(file);
                                  
                                  // Add with loading state
                                  setEditImages(prev => [...prev, { id, url: localUrl, name: file.name, file, uploading: true }]);
                                  
                                  // Upload to Supabase
                                  try {
                                    const formData = new FormData();
                                    formData.append("file", file);
                                    formData.append("userId", user?.id || "anon");
                                    
                                    const response = await fetch("/api/upload-image", {
                                      method: "POST",
                                      body: formData,
                                    });
                                    
                                    const data = await response.json();
                                    
                                    if (data.success && data.url) {
                                      URL.revokeObjectURL(localUrl);
                                      setEditImages(prev => prev.map(img => 
                                        img.id === id ? { ...img, url: data.url, uploading: false } : img
                                      ));
                                      console.log("[EditImages] Uploaded to Supabase:", data.url);
                                    } else {
                                      setEditImages(prev => prev.map(img => 
                                        img.id === id ? { ...img, uploading: false } : img
                                      ));
                                    }
                                  } catch (error) {
                                    console.error("[EditImages] Upload error:", error);
                                    setEditImages(prev => prev.map(img => 
                                      img.id === id ? { ...img, uploading: false } : img
                                    ));
                                  }
                                }
                              }
                              e.target.value = "";
                            }}
                          />
                          <ImageIcon className="w-4 h-4 text-white/40" />
                        </label>
                        <input 
                          ref={editInputRef}
                          type="text" 
                          value={editInput} 
                          onChange={(e) => setEditInput(e.target.value)} 
                          onKeyDown={(e) => {
                            if (e.key === "Enter" && !showSuggestions) handleEdit();
                            if (e.key === "Escape" && !isEditing) { setShowFloatingEdit(false); setSelectedArchNode(null); setEditImages([]); }
                          }}
                          placeholder={selectedArchNode ? `Describe changes for @${selectedArchNode}...` : "Type @ to select a component or add images..."} 
                          className="flex-1 px-3 py-2.5 rounded-lg text-sm text-white/80 placeholder:text-white/20 bg-white/[0.03] border border-white/[0.04] focus:outline-none focus:border-white/10" 
                          disabled={isEditing} 
                          autoFocus 
                        />
                        <button onClick={handleEdit} disabled={(!editInput.trim() && editImages.length === 0) || isEditing} className="btn-black px-4 rounded-lg flex items-center gap-2 disabled:opacity-50">
                          {isEditing ? <Loader2 className="w-3.5 h-3.5 animate-spin" /> : <Send className="w-3.5 h-3.5" />}
                        </button>
                      </div>
                      
                      {/* Suggestions dropdown */}
                      <AnimatePresence>
                        {showSuggestions && suggestions.length > 0 && (
                          <motion.div 
                            initial={{ opacity: 0, y: 10 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: 10 }}
                            className="suggestions-dropdown"
                          >
                            {suggestions.map(node => {
                              const Icon = getNodeIcon(node.type);
                              return (
                                <div
                                  key={node.id}
                                  onClick={() => handleSuggestionClick(node.id)}
                                  className="suggestion-item"
                                >
                                  <Icon className="w-3.5 h-3.5 icon" />
                                  <div>
                                    <span className="text-xs text-white/80">@{node.id}</span>
                                    <span className="text-[10px] text-white/40 ml-2">{node.name}</span>
                                  </div>
                                </div>
                              );
                            })}
                          </motion.div>
                        )}
                      </AnimatePresence>
                    </div>
                  </div>
                </motion.div>
              )}
            </AnimatePresence>

            {/* Node Detail Modal */}
            <AnimatePresence>
              {selectedNodeModal && (
                <motion.div 
                  initial={{ opacity: 0 }} 
                  animate={{ opacity: 1 }} 
                  exit={{ opacity: 0 }}
                  className="fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center"
                  onClick={() => setSelectedNodeModal(null)}
                >
                  <motion.div 
                    initial={{ opacity: 0, scale: 0.95 }}
                    animate={{ opacity: 1, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.95 }}
                    className="bg-[#0c0c0c] border border-white/10 rounded-2xl p-6 w-full max-w-md shadow-2xl"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <div className="flex items-start justify-between mb-4">
                      <div className="flex items-center gap-3">
                        {(() => { const Icon = getNodeIcon(selectedNodeModal.type); return <Icon className="w-6 h-6 text-[#FF6E3C]" />; })()}
                        <div>
                          <h3 className="text-lg font-semibold text-white">{selectedNodeModal.name}</h3>
                          <span className="text-xs text-white/40 uppercase">{selectedNodeModal.type}</span>
                        </div>
                      </div>
                      <button onClick={() => setSelectedNodeModal(null)} className="p-1 hover:bg-white/5 rounded">
                        <X className="w-5 h-5 text-white/40" />
                      </button>
                    </div>
                    
                    <div className="space-y-4">
                      <div>
                        <span className="text-[10px] text-white/30 uppercase">Description</span>
                        <p className="text-sm text-white/70 mt-1">{selectedNodeModal.description || "Component in the page structure"}</p>
                      </div>
                      
                      <div>
                        <span className="text-[10px] text-white/30 uppercase">User Flow</span>
                        <p className="text-sm text-white/50 mt-1">
                          {selectedNodeModal.type === "page" && "Root container for all page elements"}
                          {selectedNodeModal.type === "component" && "Reusable UI component that can contain other elements"}
                          {selectedNodeModal.type === "section" && "Major content section of the page"}
                          {selectedNodeModal.type === "interactive" && "User can click, tap, or interact with this element"}
                          {selectedNodeModal.type === "element" && "Visual or content element (text, image, etc.)"}
                        </p>
                      </div>
                      
                      {selectedNodeModal.connections && selectedNodeModal.connections.length > 0 && (
                        <div>
                          <span className="text-[10px] text-white/30 uppercase">Connected To</span>
                          <div className="flex flex-wrap gap-2 mt-2">
                            {selectedNodeModal.connections.map(conn => (
                              <span key={conn} className="px-2 py-1 bg-white/5 rounded text-xs text-white/60">@{conn}</span>
                            ))}
                          </div>
                        </div>
                      )}
                      
                      <button 
                        onClick={() => { 
                          if (isEditing) return;
                          setEditInput(`@${selectedNodeModal.id} `); 
                          setSelectedArchNode(selectedNodeModal.id);
                          setShowFloatingEdit(true); 
                          setSelectedNodeModal(null); 
                        }}
                        className="w-full mt-4 flex items-center justify-center gap-2 px-4 py-3 bg-[#FF6E3C]/10 border border-[#FF6E3C]/20 rounded-xl text-sm text-[#FF6E3C] hover:bg-[#FF6E3C]/15 transition-colors"
                      >
                        <Sparkles className="w-4 h-4" /> Edit with AI
                      </button>
                    </div>
                  </motion.div>
                </motion.div>
              )}
            </AnimatePresence>
          </div>
        </div>
      </div>
      
      {/* Mobile Bottom Navigation */}
      <div className="fixed bottom-0 left-0 right-0 z-40 md:hidden border-t border-white/10 bg-[#111]/95 backdrop-blur-xl safe-area-pb">
        <div className="flex items-center justify-around py-2">
          <button 
            onClick={() => setMobilePanel("input")}
            className={cn(
              "flex flex-col items-center gap-1 px-2 py-2 rounded-xl transition-colors",
              mobilePanel === "input" && !showHistoryMode ? "text-[#FF6E3C]" : "text-white/40"
            )}
          >
            <Film className="w-5 h-5" />
            <span className="text-[10px] font-medium">Input</span>
          </button>
          
          <button 
            onClick={() => setMobilePanel("preview")}
            className={cn(
              "flex flex-col items-center gap-1 px-2 py-2 rounded-xl transition-colors",
              mobilePanel === "preview" && !showHistoryMode ? "text-[#FF6E3C]" : "text-white/40"
            )}
          >
            <Eye className="w-5 h-5" />
            <span className="text-[10px] font-medium">Preview</span>
          </button>
          
          <button 
            onClick={() => setMobilePanel("code")}
            className={cn(
              "flex flex-col items-center gap-1 px-2 py-2 rounded-xl transition-colors",
              mobilePanel === "code" && !showHistoryMode ? "text-[#FF6E3C]" : "text-white/40"
            )}
          >
            <Code className="w-5 h-5" />
            <span className="text-[10px] font-medium">Code</span>
          </button>
          
          <button 
            onClick={() => setMobilePanel("flow")}
            className={cn(
              "flex flex-col items-center gap-1 px-2 py-2 rounded-xl transition-colors",
              mobilePanel === "flow" && !showHistoryMode ? "text-[#FF6E3C]" : "text-white/40"
            )}
          >
            <GitBranch className="w-5 h-5" />
            <span className="text-[10px] font-medium">Flow</span>
          </button>
          
          <button 
            onClick={() => setMobilePanel("design")}
            className={cn(
              "flex flex-col items-center gap-1 px-2 py-2 rounded-xl transition-colors",
              mobilePanel === "design" && !showHistoryMode ? "text-[#FF6E3C]" : "text-white/40"
            )}
          >
            <Palette className="w-5 h-5" />
            <span className="text-[10px] font-medium">Design</span>
          </button>
        </div>
      </div>
      
      {/* Mobile History Mode Panel */}
      <AnimatePresence>
        {showHistoryMode && (
          <motion.div 
            initial={{ x: "100%" }}
            animate={{ x: 0 }}
            exit={{ x: "100%" }}
            transition={{ type: "spring", damping: 25, stiffness: 300 }}
            className="fixed inset-x-0 bottom-16 top-16 z-40 md:hidden bg-[#0a0a0a] border-t border-white/10 flex flex-col"
          >
            {/* History Header */}
            <div className="p-4 border-b border-white/5 flex-shrink-0">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-2">
                  <History className="w-4 h-4 text-[#FF6E3C]" />
                  <span className="text-sm font-semibold text-white/80">History</span>
                </div>
                <button 
                  onClick={() => setShowHistoryMode(false)}
                  className="flex items-center gap-1 text-xs text-white/50 hover:text-white px-2 py-1 rounded-lg hover:bg-white/5"
                >
                  <span>Back</span>
                  <ChevronRight className="w-3 h-3" />
                </button>
              </div>
              {/* Search */}
              <div className="relative">
                <Search className="absolute left-2.5 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-white/30" />
                <input
                  type="text"
                  value={historySearch}
                  onChange={(e) => setHistorySearch(e.target.value)}
                  placeholder="Search projects..."
                  className="w-full pl-8 pr-3 py-2 rounded-lg bg-white/[0.03] border border-white/[0.06] text-sm text-white/70 placeholder:text-white/30 focus:outline-none focus:border-white/10"
                />
              </div>
            </div>
            
            {/* Generation List - sorted newest first */}
            <div className="flex-1 min-h-0 overflow-y-auto p-3 space-y-2">
              {generations.length === 0 ? (
                <div className="text-center py-12">
                  <History className="w-10 h-10 text-white/10 mx-auto mb-3" />
                  <p className="text-sm text-white/40">No generations yet</p>
                  <p className="text-xs text-white/25 mt-1">Your history will appear here</p>
                </div>
              ) : (
                generations
                  .slice()
                  .sort((a, b) => b.timestamp - a.timestamp)
                  .filter(gen => !historySearch || gen.title.toLowerCase().includes(historySearch.toLowerCase()))
                  .map((gen) => (
                  <div 
                    key={gen.id}
                    className={cn(
                      "relative p-3 pr-10 rounded-xl cursor-pointer transition-colors border",
                      activeGeneration?.id === gen.id 
                        ? "bg-[#FF6E3C]/10 border-[#FF6E3C]/30" 
                        : "bg-white/[0.02] border-white/5 hover:bg-white/5"
                    )}
                    onClick={() => {
                      // Ensure generation has versions - if not, create initial version from code
                      let genToLoad = gen;
                      if (gen.code && (!gen.versions || gen.versions.length === 0)) {
                        const initialVersion: GenerationVersion = {
                          id: generateId(),
                          timestamp: gen.timestamp,
                          label: "Initial generation",
                          code: gen.code,
                          flowNodes: gen.flowNodes || [],
                          flowEdges: gen.flowEdges || [],
                          styleInfo: gen.styleInfo || null,
                        };
                        genToLoad = { ...gen, versions: [initialVersion] };
                        setGenerations(prev => prev.map(g => g.id === gen.id ? genToLoad : g));
                      }
                      
                      setActiveGeneration(genToLoad);
                      setGenerationTitle(genToLoad.title);
                      // Reset published URL state to match the loaded generation (prevents cross-project slug confusion)
                      setPublishedUrl(genToLoad.publishedSlug ? `https://www.replay.build/p/${genToLoad.publishedSlug}` : null);
                      setShowPublishModal(false);
                      if (genToLoad.code) {
                        setGeneratedCode(genToLoad.code);
                        setDisplayedCode(genToLoad.code);
                        setEditableCode(genToLoad.code);
                        const blob = new Blob([genToLoad.code], { type: "text/html" });
                        setPreviewUrl(URL.createObjectURL(blob));
                      }
                      if (genToLoad.flowNodes) setFlowNodes(genToLoad.flowNodes);
                      if (genToLoad.flowEdges) setFlowEdges(genToLoad.flowEdges);
                      if (genToLoad.styleInfo) setStyleInfo(genToLoad.styleInfo);
                      setStyleDirective(genToLoad.styleDirective);
                      setRefinements(genToLoad.refinements);
                      
                      // Auto-expand versions if there are any
                      if (genToLoad.versions && genToLoad.versions.length > 0) {
                        setExpandedVersions(genToLoad.id);
                      }
                      
                      // Restore video from generation if available
                      if (genToLoad.videoUrl && !flows.some(f => f.videoUrl === genToLoad.videoUrl)) {
                        const newFlow: FlowItem = {
                          id: generateId(),
                          name: genToLoad.title || "Recording",
                          videoBlob: new Blob(), // Empty blob as placeholder
                          videoUrl: genToLoad.videoUrl,
                          thumbnail: genToLoad.thumbnailUrl || "",
                          duration: 30,
                          trimStart: 0,
                          trimEnd: 30,
                        };
                        setFlows([newFlow]);
                        setSelectedFlowId(newFlow.id);
                      }
                      setShowHistoryMode(false);
                      setGenerationComplete(true);
                    }}
                  >
                    <div className="flex items-center gap-2 mb-1">
                      <p className="text-sm font-medium text-white/80 truncate flex-1">{gen.title}</p>
                    </div>
                    <p className="text-[10px] text-white/30">
                      {new Date(gen.timestamp).toLocaleDateString()}  {new Date(gen.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                    </p>
                    {/* Delete action - right aligned */}
                    <div className="absolute top-3 right-3">
                      <button
                        onClick={(e) => { e.stopPropagation(); deleteGeneration(gen.id); }}
                        className="p-1.5 rounded-lg bg-white/5 hover:bg-red-500/20 text-white/30 hover:text-red-400 transition-colors"
                      >
                        <Trash2 className="w-3.5 h-3.5" />
                      </button>
                    </div>
                    
                    {/* Version History Toggle - Mobile */}
                    {gen.versions && gen.versions.length >= 1 && (
                      <div className="mt-2 pt-2 border-t border-white/5">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setExpandedVersions(expandedVersions === gen.id ? null : gen.id);
                          }}
                          className="flex items-center gap-2 text-[10px] text-white/40 hover:text-white/60 transition-colors"
                        >
                          <Clock className="w-3 h-3" />
                          <span>{gen.versions.length} version{gen.versions.length !== 1 ? 's' : ''}</span>
                          <ChevronDown className={cn(
                            "w-3 h-3 transition-transform",
                            expandedVersions === gen.id && "rotate-180"
                          )} />
                        </button>
                        
                        <AnimatePresence>
                          {expandedVersions === gen.id && (
                            <motion.div
                              initial={{ opacity: 0, height: 0 }}
                              animate={{ opacity: 1, height: "auto" }}
                              exit={{ opacity: 0, height: 0 }}
                              className="mt-2 ml-1 space-y-1 overflow-hidden"
                            >
                              <div className="relative pl-3 border-l border-white/10">
                                {gen.versions.slice().reverse().map((version, idx) => (
                                  <div 
                                    key={version.id}
                                    className="relative py-1.5"
                                  >
                                    <div className={cn(
                                      "absolute -left-[7px] top-2.5 w-2.5 h-2.5 rounded-full border-2",
                                      idx === 0 
                                        ? "bg-[#FF6E3C] border-[#FF6E3C]" 
                                        : "bg-[#0a0a0a] border-white/20"
                                    )} />
                                    
                                    <div className="flex items-center justify-between gap-2 pl-2">
                                      <div className="flex-1 min-w-0">
                                        <p className="text-[10px] text-white/50 truncate">{version.label}</p>
                                        <p className="text-[8px] text-white/25">
                                          {new Date(version.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                        </p>
                                      </div>
                                      
                                      {idx !== 0 ? (
                                        <button
                                          onClick={(e) => {
                                            e.stopPropagation();
                                            restoreVersion(gen.id, version);
                                          }}
                                          className="p-1.5 rounded bg-white/5 hover:bg-white/10 transition-all"
                                          title="Restore"
                                        >
                                          <Play className="w-3 h-3 text-[#FF6E3C]" />
                                        </button>
                                      ) : (
                                        <span className="text-[8px] text-[#FF6E3C]/60 uppercase">Current</span>
                                      )}
                                    </div>
                                  </div>
                                ))}
                              </div>
                            </motion.div>
                          )}
                        </AnimatePresence>
                      </div>
                    )}
                  </div>
                ))
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Mobile Input Panel - Full layout like desktop */}
      <AnimatePresence>
        {mobilePanel === "input" && !showHistoryMode && (
          <motion.div 
            initial={{ y: "100%" }}
            animate={{ y: 0 }}
            exit={{ y: "100%" }}
            transition={{ type: "spring", damping: 25, stiffness: 300 }}
            className="fixed inset-x-0 bottom-16 top-16 z-30 md:hidden bg-[#0a0a0a] border-t border-white/10 overflow-auto"
          >
            <div className="flex flex-col h-full">
              {/* Project Title Header - like desktop */}
              <div className="p-4 border-b border-white/5 flex-shrink-0">
                <div className="flex items-center gap-2">
                  <div className="flex-1 min-w-0 flex items-center gap-1.5">
                    <input 
                      type="text"
                      value={generationTitle}
                      onChange={(e) => {
                        const newTitle = e.target.value;
                        setGenerationTitle(newTitle);
                        if (activeGeneration) {
                          setActiveGeneration(prev => prev ? { ...prev, title: newTitle } : null);
                          setGenerations(prev => prev.map(g => 
                            g.id === activeGeneration.id ? { ...g, title: newTitle } : g
                          ));
                        }
                      }}
                      className="flex-1 min-w-0 text-sm font-medium text-white/80 bg-transparent border-none focus:outline-none truncate"
                      placeholder="Untitled Project"
                    />
                    <Pencil className="w-3 h-3 text-white/30 flex-shrink-0" />
                  </div>
                  <button 
                    onClick={() => {
                      setGeneratedCode(null);
                      setDisplayedCode("");
                      setEditableCode("");
                      setPreviewUrl(null);
                      setFlowNodes([]);
                      setFlowEdges([]);
                      setStyleInfo(null);
                      setGenerationTitle("Untitled Project");
                      setGenerationComplete(false);
                      setActiveGeneration(null);
                    }}
                    className="p-1.5 rounded-lg hover:bg-white/5"
                    title="New generation"
                  >
                    <Plus className="w-4 h-4 text-white/40" />
                  </button>
                  <button 
                    onClick={() => setShowHistoryMode(true)}
                    className={cn(
                      "p-1.5 rounded-lg hover:bg-white/5",
                      generations.length === 0 && "opacity-30 pointer-events-none"
                    )}
                    title="View history"
                  >
                    <History className="w-4 h-4 text-white/40" />
                  </button>
                </div>
              </div>

              {/* Videos Section */}
              <div className="p-4 border-b border-white/5 flex-shrink-0">
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center gap-2">
                    <Video className="w-4 h-4 text-white/40" />
                    <span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Videos</span>
                  </div>
                  <div className="flex gap-1.5">
                    {isRecording ? (
                      <button onClick={stopRecording} className="flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs bg-red-500/20 text-red-400">
                        <Square className="w-3 h-3 fill-current" />{formatDuration(recordingDuration)}
                      </button>
                    ) : (
                      <button onClick={startRecording} className="flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs bg-white/5 text-white/60">
                        <Monitor className="w-3.5 h-3.5" /> Record
                      </button>
                    )}
                    <button onClick={() => fileInputRef.current?.click()} className="flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs bg-white/5 text-white/60">
                      <Upload className="w-3.5 h-3.5" /> Upload
                    </button>
                  </div>
                </div>
                
                <div className="space-y-2 max-h-[140px] overflow-auto">
                  {flows.length === 0 ? (
                    <div 
                      onClick={() => fileInputRef.current?.click()} 
                      className="relative rounded-xl border-2 border-dashed border-white/[0.08] bg-white/[0.02] hover:border-white/[0.15] hover:bg-white/[0.03] transition-all cursor-pointer"
                    >
                      <div className="p-5 text-center">
                        <Video className="w-5 h-5 text-white/30 mx-auto mb-2" />
                        <p className="text-[10px] text-white/40">
                          Drop your video here
                        </p>
                        <p className="text-[9px] text-white/25 mt-1">
                          Screen recording, product demo, or UI walkthrough
                        </p>
                      </div>
                    </div>
                  ) : flows.map((flow) => (
                    <div 
                      key={flow.id} 
                      onClick={() => setSelectedFlowId(flow.id)}
                      className={cn(
                        "flex items-center gap-2.5 p-2 rounded-lg cursor-pointer",
                        selectedFlowId === flow.id ? "bg-[#FF6E3C]/10 border border-[#FF6E3C]/30" : "bg-white/5"
                      )}
                    >
                      <div className="w-14 h-8 rounded overflow-hidden bg-white/5 flex-shrink-0 flex items-center justify-center">
                        {flow.thumbnail ? <img src={flow.thumbnail} alt="" className="w-full h-full object-cover" /> : <Film className="w-3 h-3 text-white/20" />}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="text-sm font-medium text-white/80 truncate">{flow.name}</p>
                        <p className="text-xs text-white/40">{formatDuration(flow.trimEnd - flow.trimStart)} / {formatDuration(flow.duration)}</p>
                      </div>
                      <button onClick={(e) => { e.stopPropagation(); removeFlow(flow.id); }} className="p-1 hover:bg-white/10 rounded">
                        <Trash2 className="w-3 h-3 text-white/40" />
                      </button>
                    </div>
                  ))}
                </div>
              </div>

              {/* Context Section */}
              <div className="p-4 border-b border-white/5 flex-shrink-0">
                <div className="flex items-center gap-2 mb-3">
                  <Sparkles className="w-4 h-4 text-white/40" />
                  <span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Context</span>
                </div>
                {/* Textarea only */}
                <textarea
                  value={refinements}
                  onChange={(e) => setRefinements(e.target.value)}
                  placeholder="Describe what you observed (optional)"
                  disabled={isProcessing}
                  rows={3}
                  className="w-full px-3 py-3 rounded-lg text-xs text-white/70 placeholder:text-white/30 placeholder:text-[11px] bg-white/[0.03] border border-white/[0.06] focus:outline-none focus:border-[#FF6E3C]/20 min-h-[80px]"
                />
              </div>

              {/* Style Section */}
              <div className="p-4 border-b border-white/5 flex-shrink-0">
                <div className="flex items-center gap-2 mb-3">
                  <Palette className="w-4 h-4 text-white/40" />
                  <span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Style</span>
                </div>
                <StyleInjector 
                  value={styleDirective} 
                  onChange={setStyleDirective} 
                  disabled={isProcessing}
                  referenceImage={styleReferenceImage}
                  onReferenceImageChange={setStyleReferenceImage}
                />
              </div>

              {/* Generate Button */}
              <div className="p-4 border-b border-white/5 flex-shrink-0">
                {(() => {
                  // Determine if we're in update mode (existing project + changed context)
                  const hasProject = activeGeneration && generatedCode && generationComplete;
                  const hasContextChange = refinements.trim() !== (activeGeneration?.refinements || "").trim();
                  const hasStyleChange = styleDirective.trim() !== (activeGeneration?.styleDirective || "").trim();
                  const isUpdateMode = hasProject && (hasContextChange || hasStyleChange) && refinements.trim();
                  
                  return (
                    <button 
                      onClick={handleGenerate}
                      disabled={isProcessing || isEditing || flows.length === 0}
                      className={cn(
                        "w-full flex items-center justify-center gap-2.5 py-3.5 rounded-xl font-semibold text-sm transition-all",
                        (isProcessing || isEditing) ? "bg-[#FF6E3C]/80" : "bg-gradient-to-r from-[#FF6E3C] to-[#FF8F5C]",
                        "text-white shadow-lg shadow-[#FF6E3C]/30 disabled:opacity-50"
                      )}
                    >
                      {isProcessing || isEditing ? (
                        <><Loader2 className="w-4 h-4 animate-spin" /><span>{isEditing ? "Updating..." : "Reconstructing..."}</span></>
                      ) : (
                        <><LogoIcon className="w-5 h-5" color="white" /><span>Reconstruct</span><ChevronRight className="w-4 h-4" /></>
                      )}
                    </button>
                  );
                })()}
              </div>

              {/* Analysis Section */}
              <div className="flex-1 flex flex-col min-h-0">
                <div className="px-4 py-3 border-b border-white/5 flex items-center gap-2 flex-shrink-0">
                  <Activity className="w-4 h-4 text-white/40" />
                  <span className="text-xs font-semibold text-white/60 uppercase tracking-wider">Analysis</span>
                </div>
                <div className="flex-1 p-4 overflow-auto">
                  {(isProcessing || isStreamingCode) && analysisPhase ? (
                    <div className="space-y-4">
                      {/* UX Signals */}
                      <div className="bg-white/[0.02] rounded-lg p-3">
                        <div className="flex items-center gap-2 mb-2">
                          <Activity className="w-3.5 h-3.5 text-[#FF6E3C]/60" />
                          <span className="text-[10px] font-semibold text-white/40 uppercase tracking-wider">UX Signals</span>
                        </div>
                        <div className="space-y-1.5">
                          {analysisPhase.uxSignals && analysisPhase.uxSignals.length > 0 ? (
                            analysisPhase.uxSignals.map((signal, i) => (
                              <div key={signal.label} className="flex items-center justify-between">
                                <span className="text-[10px] text-white/30">{signal.label}</span>
                                <span className="text-[10px] text-white/50">{signal.value}</span>
                              </div>
                            ))
                          ) : (
                            <div className="flex items-center gap-2 text-[10px] text-white/30">
                              <Loader2 className="w-3 h-3 animate-spin text-[#FF6E3C]/50" />
                              <span>Detecting UX patterns...</span>
                            </div>
                          )}
                        </div>
                      </div>
                      
                      {/* Structure & Components */}
                      {analysisPhase.structureItems && analysisPhase.structureItems.length > 0 && (
                        <div className="bg-white/[0.02] rounded-lg p-3">
                          <div className="flex items-center gap-2 mb-2">
                            <GitBranch className="w-3.5 h-3.5 text-[#FF6E3C]/60" />
                            <span className="text-[10px] font-semibold text-white/40 uppercase tracking-wider">Structure</span>
                          </div>
                          <div className="space-y-1">
                            {analysisPhase.structureItems.map((item, i) => (
                              <div key={item.name} className="flex items-center gap-2">
                                <div className={cn("w-1.5 h-1.5 rounded-full", item.status === "done" ? "bg-green-500/60" : "bg-[#FF6E3C]/40")} />
                                <span className="text-[10px] text-white/50">{item.name}</span>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  ) : !generatedCode ? (
                    <div className="flex flex-col items-center justify-center h-full text-center py-8">
                      <Clock className="w-8 h-8 text-white/10 mb-3" />
                      <p className="text-xs font-medium text-white/40 uppercase tracking-wider">Waiting for generation</p>
                      <p className="text-[10px] text-white/25 mt-1">Live analysis logs will display here once generation starts.</p>
                    </div>
                  ) : (
                    <div className="space-y-2">
                      <div className="flex items-center gap-2">
                        <Check className="w-4 h-4 text-green-500/60" />
                        <span className="text-xs text-white/60">Generation complete</span>
                      </div>
                      {styleInfo && (
                        <p className="text-[10px] text-white/40">{styleInfo.colors.length} colors, {styleInfo.fonts.length} fonts detected</p>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Mobile Preview Panel */}
      <AnimatePresence>
        {mobilePanel === "preview" && (
          <motion.div 
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-x-0 bottom-16 top-16 z-30 md:hidden bg-[#0a0a0a] overflow-hidden"
          >
            {(isProcessing || isStreamingCode) ? (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <LoadingState />
              </div>
            ) : previewUrl ? (
              <div className="w-full h-full overflow-hidden">
                <iframe 
                  key={previewUrl}
                  src={previewUrl} 
                  className="w-full h-full border-0 bg-white" 
                  style={{ 
                    overflow: 'hidden',
                    touchAction: 'pan-y', // Only allow vertical scroll
                  }}
                />
              </div>
            ) : (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <div className="w-16 h-16 rounded-2xl bg-gradient-to-br from-[#FF6E3C]/20 to-[#FF8F5C]/10 flex items-center justify-center mb-4">
                  <Eye className="w-8 h-8 text-[#FF6E3C]/50" />
                </div>
                <p className="text-sm text-white/50 font-medium">No preview yet</p>
                <p className="text-xs text-white/30 mt-1">Generate to see preview</p>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Mobile Code Panel - With syntax highlighting like desktop */}
      <AnimatePresence>
        {mobilePanel === "code" && (
          <motion.div 
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-x-0 bottom-16 top-16 z-30 md:hidden bg-[#0a0a0a] flex flex-col"
          >
            {(isProcessing || isStreamingCode) ? (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <LoadingState />
              </div>
            ) : generatedCode ? (
              <>
                {/* Header with toggle, copy, and download */}
                <div className="flex items-center justify-between p-3 border-b border-white/10 flex-shrink-0">
                  <div className="flex items-center gap-1">
                    <button
                      onClick={() => setCodeMode("single-file")}
                      className={cn(
                        "text-[10px] px-2 py-1 rounded-md transition-colors",
                        codeMode === "single-file" ? "bg-white/10 text-white" : "text-white/40"
                      )}
                    >
                      Single-file
                    </button>
                    <button
                      onClick={() => generationComplete && setCodeMode("componentized")}
                      disabled={!generationComplete}
                      className={cn(
                        "text-[10px] px-2 py-1 rounded-md transition-colors",
                        codeMode === "componentized" ? "bg-white/10 text-white" : "text-white/40",
                        !generationComplete && "opacity-50"
                      )}
                    >
                      Componentized
                    </button>
                  </div>
                  <div className="flex items-center gap-2">
                    <button 
                      onClick={() => {
                        navigator.clipboard.writeText(getActiveFileContent());
                        showToast("Copied!", "success");
                      }} 
                      className="text-[10px] text-white/40 hover:text-white/60 flex items-center gap-1"
                    >
                      <Copy className="w-3 h-3" />
                    </button>
                    <button 
                      onClick={handleDownload}
                      className="text-[10px] text-white/40 hover:text-white/60 flex items-center gap-1"
                    >
                      <Download className="w-3 h-3" />
                    </button>
                  </div>
                </div>
                
                {/* File tree (compact for mobile) */}
                {codeMode === "componentized" && generatedFiles.length > 0 && (
                  <div className="flex overflow-x-auto gap-1 p-2 border-b border-white/5 flex-shrink-0">
                    {generatedFiles.filter(f => !f.isStub).slice(0, 8).map(file => (
                      <button
                        key={file.path}
                        onClick={() => setActiveFilePath(file.path)}
                        className={cn(
                          "text-[9px] px-2 py-1 rounded whitespace-nowrap flex-shrink-0",
                          activeFilePath === file.path 
                            ? "bg-[#FF6E3C]/20 text-[#FF6E3C]" 
                            : "bg-white/5 text-white/50"
                        )}
                      >
                        {file.name}
                      </button>
                    ))}
                  </div>
                )}
                
                {/* Code display with syntax highlighting */}
                <div className="flex-1 overflow-auto bg-[#0a0a0a]">
                  {generatingFilePath && generatingFilePath === activeFilePath ? (
                    <div className="w-full h-full flex flex-col items-center justify-center gap-3">
                      <Loader2 className="w-6 h-6 text-[#FF6E3C] animate-spin" />
                      <div className="text-center">
                        <p className="text-xs text-white/60">Generating page...</p>
                        <p className="text-[10px] text-white/30 mt-0.5">{activeFilePath.split('/').pop()}</p>
                      </div>
                    </div>
                  ) : (
                    <Highlight 
                      theme={themes.nightOwl} 
                      code={getActiveFileContent()} 
                      language={activeFilePath.endsWith('.tsx') || activeFilePath.endsWith('.ts') ? 'tsx' : 'html'}
                    >
                      {({ style, tokens, getLineProps, getTokenProps }) => (
                        <pre 
                          className="p-3 text-[10px] leading-relaxed min-h-full" 
                          style={{ 
                            ...style, 
                            background: "#0a0a0a", 
                            fontFamily: "'JetBrains Mono', 'SF Mono', monospace",
                          }}
                        >
                          {tokens.map((line, i) => (
                            <div key={i} {...getLineProps({ line })}>
                              <span className="inline-block w-6 pr-2 text-right text-white/15 select-none text-[9px]">{i + 1}</span>
                              {line.map((token, key) => <span key={key} {...getTokenProps({ token })} />)}
                            </div>
                          ))}
                        </pre>
                      )}
                    </Highlight>
                  )}
                </div>
                
                {/* Edit with AI button */}
                {!showFloatingEdit && !isStreamingCode && (
                  <div className="flex-shrink-0 p-3 border-t border-white/5">
                    <button 
                      onClick={() => setShowFloatingEdit(true)} 
                      className="w-full flex items-center justify-center gap-2 py-2.5 rounded-xl bg-white/5 border border-white/10 text-white/70 text-xs font-medium"
                    >
                      <Sparkles className="w-3.5 h-3.5 text-[#FF6E3C]" /> Edit with AI
                    </button>
                  </div>
                )}
              </>
            ) : (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <div className="w-16 h-16 rounded-2xl bg-gradient-to-br from-[#FF6E3C]/20 to-[#FF8F5C]/10 flex items-center justify-center mb-4">
                  <Code className="w-8 h-8 text-[#FF6E3C]/50" />
                </div>
                <p className="text-sm text-white/50 font-medium">No code yet</p>
                <p className="text-xs text-white/30 mt-1">Generate to see code</p>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Mobile Flow Panel - Product Map with toggles like desktop */}
      <AnimatePresence>
        {mobilePanel === "flow" && (
          <motion.div 
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-x-0 bottom-16 top-16 z-30 md:hidden bg-[#0a0a0a] flex flex-col"
          >
            {flowNodes.length > 0 ? (
              <>
                {/* Header with toggles */}
                <div className="flex items-center justify-between p-3 border-b border-white/10 flex-shrink-0">
                  <div>
                    <span className="text-xs text-white/50 flex items-center gap-1.5">
                      <GitBranch className="w-3.5 h-3.5 text-[#FF6E3C]" />
                      Product Flow
                    </span>
                    <p className="text-[10px] text-white/30 mt-0.5">Views, states, and what's possible</p>
                  </div>
                  <div className="flex gap-1">
                    <button 
                      onClick={() => setShowPossiblePaths(!showPossiblePaths)}
                      className={cn(
                        "text-[9px] px-2 py-1 rounded-lg flex items-center gap-1",
                        showPossiblePaths ? "bg-[#FF6E3C]/20 text-[#FF6E3C]" : "bg-white/5 text-white/40"
                      )}
                    >
                      <GitBranch className="w-2.5 h-2.5" />
                      Possible
                    </button>
                    <button 
                      onClick={() => setShowStructureInFlow(!showStructureInFlow)}
                      className={cn(
                        "text-[9px] px-2 py-1 rounded-lg flex items-center gap-1",
                        showStructureInFlow ? "bg-[#FF6E3C]/20 text-[#FF6E3C]" : "bg-white/5 text-white/40"
                      )}
                    >
                      <Layers className="w-2.5 h-2.5" />
                      Structure
                    </button>
                  </div>
                </div>
                
                {/* Flow nodes list */}
                <div className="flex-1 overflow-auto p-4 space-y-3">
                  {flowNodes
                    .filter(node => showPossiblePaths || node.status === "observed" || node.status === "added")
                    .map(node => {
                    const isObserved = node.status === "observed";
                    const isDetected = node.status === "detected";
                    const isPossible = node.status === "possible";
                    return (
                      <div 
                        key={node.id} 
                        className={cn(
                          "p-3 rounded-xl border",
                          isObserved
                            ? "border-emerald-500/30 bg-emerald-500/5"
                            : isDetected 
                            ? "border-amber-500/30 bg-amber-500/5" 
                            : isPossible 
                            ? "border-dashed border-white/20 bg-white/5 opacity-60" 
                            : "border-[#FF6E3C]/30 bg-[#FF6E3C]/5"
                        )}
                        onClick={() => {
                          if (isEditing) return;
                          if (isDetected || isPossible) {
                            // Full prompt like on desktop
                            setEditInput(`@${node.name} Create this page with the same style and navigation as the main page`);
                            setShowFloatingEdit(true);
                          }
                        }}
                      >
                        <div className="flex items-center justify-between mb-1">
                          <div className="flex items-center gap-2">
                            {isObserved && <div className="w-1.5 h-1.5 rounded-full bg-emerald-400" />}
                            {isDetected && <div className="w-1.5 h-1.5 rounded-full bg-amber-400" />}
                            {isPossible && <div className="w-1.5 h-1.5 rounded-full bg-white/40" />}
                            <p className={cn(
                              "text-sm font-medium",
                              isPossible ? "text-white/50 italic" : isDetected ? "text-white/70" : "text-white/80"
                            )}>{node.name}</p>
                          </div>
                          <span className={cn(
                            "text-[8px] px-1.5 py-0.5 rounded uppercase",
                            isPossible ? "bg-white/5 text-white/30" : isDetected ? "bg-amber-500/10 text-amber-400/60" : "bg-emerald-500/10 text-emerald-400/60"
                          )}>
                            {isPossible ? "possible" : isDetected ? "detected" : "observed"}
                          </span>
                        </div>
                        {node.description && (
                          <p className={cn("text-xs", isPossible ? "text-white/25" : isDetected ? "text-white/30" : "text-white/40")}>
                            {node.description}
                          </p>
                        )}
                        
                        {/* Structure components (when toggle is ON) */}
                        {showStructureInFlow && node.components && node.components.length > 0 && (
                          <div className="mt-2 pt-2 border-t border-white/10">
                            <span className="text-[9px] text-white/30 uppercase">Components:</span>
                            <div className="flex flex-wrap gap-1 mt-1">
                              {node.components.map((comp, i) => (
                                <span key={i} className="text-[10px] px-1.5 py-0.5 rounded bg-white/5 text-white/50">{comp}</span>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })}
                  
                  {/* Transitions section inside scrollable area */}
                  {flowEdges.filter(e => showPossiblePaths || e.type !== "possible").length > 0 && (
                    <div className="mt-4 pt-4 border-t border-white/10">
                      <span className="text-xs text-white/50 block mb-2">Transitions</span>
                      {flowEdges
                        .filter(e => showPossiblePaths || e.type !== "possible")
                        .slice(0, 10)
                        .map(edge => {
                          const fromNode = flowNodes.find(n => n.id === edge.from);
                          const toNode = flowNodes.find(n => n.id === edge.to);
                          if (!fromNode || !toNode) return null;
                          return (
                            <div key={edge.id} className="text-[10px] text-white/40 py-1 flex items-center gap-1">
                              <span className="text-white/60">{fromNode.name}</span>
                              <span className="text-white/20"></span>
                              <span className="text-[#FF6E3C]/70">{edge.label}</span>
                              <span className="text-white/20"></span>
                              <span className={cn(
                                toNode.status === "possible" ? "text-white/30 italic" : 
                                toNode.status === "detected" ? "text-amber-400/50" : "text-white/60"
                              )}>
                                {toNode.name}
                              </span>
                            </div>
                          );
                        })}
                    </div>
                  )}
                </div>
                
                {/* Edit with AI button */}
                {!showFloatingEdit && !isProcessing && (
                  <div className="flex-shrink-0 p-3 border-t border-white/5">
                    <button 
                      onClick={() => setShowFloatingEdit(true)} 
                      className="w-full flex items-center justify-center gap-2 py-2.5 rounded-xl bg-white/5 border border-white/10 text-white/70 text-xs font-medium"
                    >
                      <Sparkles className="w-3.5 h-3.5 text-[#FF6E3C]" /> Edit with AI
                    </button>
                  </div>
                )}
              </>
            ) : (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <div className="w-16 h-16 rounded-2xl bg-gradient-to-br from-[#FF6E3C]/20 to-[#FF8F5C]/10 flex items-center justify-center mb-4">
                  <GitBranch className="w-8 h-8 text-[#FF6E3C]/50" />
                </div>
                <p className="text-sm text-white/50 font-medium">No product flow yet</p>
                <p className="text-xs text-white/30 mt-1">Flow shows what's possible in the product</p>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Mobile Design System Panel - Now uses styleInfo like desktop */}
      <AnimatePresence>
        {mobilePanel === "design" && (
          <motion.div 
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-x-0 bottom-16 top-16 z-30 md:hidden bg-[#0a0a0a] overflow-auto"
          >
            {styleInfo ? (
              <div className="p-4 space-y-6">
                {/* Colors */}
                <div>
                  <span className="text-xs text-white/50 flex items-center gap-1.5 mb-3">
                    <div className="w-2 h-2 rounded-full bg-[#FF6E3C]" />
                    Colors
                  </span>
                  <div className="grid grid-cols-4 gap-2">
                    {styleInfo.colors.slice(0, 8).map((color, i) => (
                      <div key={i} className="space-y-1">
                        <div 
                          className="h-12 rounded-lg border border-white/10" 
                          style={{ backgroundColor: color.value }} 
                        />
                        <p className="text-[9px] text-white/40 text-center truncate">{color.name || color.value}</p>
                      </div>
                    ))}
                  </div>
                </div>
                
                {/* Typography */}
                {styleInfo.fonts.length > 0 && (
                  <div>
                    <span className="text-xs text-white/50 flex items-center gap-1.5 mb-3">
                      <Type className="w-3 h-3 text-[#FF6E3C]" />
                      Typography
                    </span>
                    <div className="space-y-2">
                      {styleInfo.fonts.map((font, i) => (
                        <div key={i} className="p-2 bg-white/5 rounded-lg">
                          <p className="text-sm text-white/70" style={{ fontFamily: font.family }}>
                            {font.family || font.name}
                          </p>
                          <p className="text-[10px] text-white/30">{font.usage || font.weight}</p>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                {/* Spacing & Radius */}
                <div className="grid grid-cols-2 gap-4">
                  {styleInfo.spacing && (
                    <div>
                      <span className="text-xs text-white/50 block mb-2">Spacing</span>
                      <p className="text-sm text-white/70">{styleInfo.spacing}</p>
                    </div>
                  )}
                  {styleInfo.borderRadius && (
                    <div>
                      <span className="text-xs text-white/50 block mb-2">Radius</span>
                      <p className="text-sm text-white/70">{styleInfo.borderRadius}</p>
                    </div>
                  )}
                </div>
                
                {/* Shadows */}
                {styleInfo.shadows && (
                  <div>
                    <span className="text-xs text-white/50 block mb-2">Shadows</span>
                    <p className="text-sm text-white/70">{styleInfo.shadows}</p>
                  </div>
                )}
              </div>
            ) : (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <div className="w-16 h-16 rounded-2xl bg-gradient-to-br from-[#FF6E3C]/20 to-[#FF8F5C]/10 flex items-center justify-center mb-4">
                  <Palette className="w-8 h-8 text-[#FF6E3C]/50" />
                </div>
                <p className="text-sm text-white/50 font-medium">No style analysis yet</p>
                <p className="text-xs text-white/30 mt-1">Generate to see design system</p>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Mobile Floating Edit - Appears above bottom navigation */}
      <AnimatePresence>
        {showFloatingEdit && (
          <motion.div 
            initial={{ opacity: 0, y: 20 }} 
            animate={{ opacity: 1, y: 0 }} 
            exit={{ opacity: 0, y: 20 }}
            className="fixed bottom-[72px] left-2 right-2 z-50 md:hidden"
          >
            <div className="backdrop-blur-xl bg-[#0a0a0a]/95 border border-white/[0.08] rounded-2xl p-3 shadow-2xl mx-auto max-w-[calc(100%-16px)]">
              <div className="flex items-center gap-2 mb-2">
                {isEditing ? (
                  <Loader2 className="w-3.5 h-3.5 text-[#FF6E3C] animate-spin" />
                ) : (
                  <Sparkles className="w-3.5 h-3.5 text-[#FF6E3C]" />
                )}
                <span className="text-xs text-white/50 flex-1">
                  {isEditing ? (
                    <span className="text-[#FF6E3C]/80 animate-pulse">
                      {selectedElement ? `Editing ${selectedElement.substring(0, 20)}...` : editInput.includes('@') ? `Creating ${editInput.match(/@([a-zA-Z0-9-_]+)/)?.[1] || 'page'}...` : 'Applying changes...'}
                    </span>
                  ) : selectedArchNode ? (
                    <>Editing <span className="text-[#FF6E3C]">@{selectedArchNode}</span></>
                  ) : "Describe your changes"}
                </span>
                {!isEditing && (
                  <button 
                    onClick={() => { setShowFloatingEdit(false); setSelectedArchNode(null); setShowSuggestions(false); }} 
                    className="p-1 hover:bg-white/5 rounded"
                  >
                    <X className="w-3.5 h-3.5 text-white/30" />
                  </button>
                )}
              </div>
              {/* Image previews for mobile */}
              {editImages.length > 0 && (
                <div className="flex flex-wrap gap-2 mb-2">
                  {editImages.map(img => (
                    <div key={img.id} className="relative group">
                      <img src={img.url} alt={img.name} className="w-10 h-10 object-cover rounded-lg border border-white/10" />
                      <button 
                        onClick={() => {
                          URL.revokeObjectURL(img.url);
                          setEditImages(prev => prev.filter(i => i.id !== img.id));
                        }}
                        className="absolute -top-1.5 -right-1.5 w-4 h-4 bg-red-500 rounded-full flex items-center justify-center"
                      >
                        <X className="w-2.5 h-2.5 text-white" />
                      </button>
                    </div>
                  ))}
                </div>
              )}
              <div className="flex gap-2">
                {/* Image upload button for mobile */}
                <label className="flex items-center justify-center w-10 h-10 rounded-lg bg-white/[0.03] border border-white/[0.06] cursor-pointer">
                  <input 
                    type="file"
                    accept="image/*"
                    multiple
                    className="hidden"
                    onChange={async (e) => {
                      const files = e.target.files;
                      if (files) {
                        for (const file of Array.from(files)) {
                          const id = `img_${Date.now()}_${Math.random().toString(36).slice(2)}`;
                          const localUrl = URL.createObjectURL(file);
                          
                          setEditImages(prev => [...prev, { id, url: localUrl, name: file.name, file, uploading: true }]);
                          
                          try {
                            const formData = new FormData();
                            formData.append("file", file);
                            formData.append("userId", user?.id || "anon");
                            
                            const response = await fetch("/api/upload-image", {
                              method: "POST",
                              body: formData,
                            });
                            
                            const data = await response.json();
                            
                            if (data.success && data.url) {
                              URL.revokeObjectURL(localUrl);
                              setEditImages(prev => prev.map(img => 
                                img.id === id ? { ...img, url: data.url, uploading: false } : img
                              ));
                            } else {
                              setEditImages(prev => prev.map(img => 
                                img.id === id ? { ...img, uploading: false } : img
                              ));
                            }
                          } catch (error) {
                            setEditImages(prev => prev.map(img => 
                              img.id === id ? { ...img, uploading: false } : img
                            ));
                          }
                        }
                      }
                      e.target.value = "";
                    }}
                  />
                  <ImageIcon className="w-4 h-4 text-white/40" />
                </label>
                <input 
                  type="text" 
                  value={editInput} 
                  onChange={(e) => setEditInput(e.target.value)} 
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && !showSuggestions) handleEdit();
                    if (e.key === "Escape" && !isEditing) { setShowFloatingEdit(false); setSelectedArchNode(null); setEditImages([]); }
                  }}
                  placeholder={selectedArchNode ? `Describe changes for @${selectedArchNode}...` : "Type @ or add images..."} 
                  className="flex-1 px-3 py-2.5 rounded-lg text-sm text-white/80 placeholder:text-white/20 bg-white/[0.03] border border-white/[0.06] focus:outline-none focus:border-white/10" 
                  disabled={isEditing} 
                  autoFocus 
                />
                <button 
                  onClick={handleEdit} 
                  disabled={(!editInput.trim() && editImages.length === 0) || isEditing} 
                  className="px-4 py-2.5 rounded-lg bg-[#FF6E3C] text-white font-medium flex items-center gap-2 disabled:opacity-50"
                >
                  {isEditing ? <Loader2 className="w-4 h-4 animate-spin" /> : <Send className="w-4 h-4" />}
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Auth Modal */}
      <AuthModal
        isOpen={showAuthModal}
        onClose={() => {
          setShowAuthModal(false);
          setPendingAction(null);
        }}
        title="Sign in to generate"
        description="Your credits and projects are saved to your account."
      />
      
      {/* Out of Credits Modal */}
      <OutOfCreditsModal
        isOpen={showOutOfCreditsModal}
        onClose={() => setShowOutOfCreditsModal(false)}
        requiredCredits={pendingAction === "generate" ? CREDIT_COSTS.VIDEO_GENERATE : CREDIT_COSTS.AI_EDIT}
        availableCredits={userTotalCredits}
      />
      
      {/* Feedback Gate Modal - shows after first generation */}
      <FeedbackGateModal
        isOpen={showFeedbackModal}
        onClose={() => setShowFeedbackModal(false)}
        generationId={activeGeneration?.id}
        userId={user?.id}
      />
      
      {/* Project Settings Modal */}
      <ProjectSettingsModal
        isOpen={showProjectSettings}
        onClose={() => setShowProjectSettings(false)}
        project={{
          id: activeGeneration?.id || `project_${Date.now()}`,
          name: generationTitle || "Untitled Project",
          createdAt: new Date().toISOString(),
        }}
        onDelete={(id) => {
          // Delete project from generations
          setGenerations(prev => prev.filter(g => g.id !== id));
          if (activeGeneration?.id === id) {
            setActiveGeneration(null);
            setGeneratedCode(null);
            setDisplayedCode("");
            setEditableCode("");
            setPreviewUrl(null);
            setGenerationTitle("Untitled Project");
          }
        }}
        onRename={(id, newName) => {
          setGenerationTitle(newName);
          if (activeGeneration?.id === id) {
            setActiveGeneration(prev => prev ? { ...prev, title: newName } : null);
          }
          setGenerations(prev => prev.map(g => g.id === id ? { ...g, title: newName } : g));
        }}
      />
      
      {/* Global file input for video upload - accessible from both mobile and desktop */}
      <input 
        ref={fileInputRef} 
        type="file" 
        accept="video/*,video/mp4,video/quicktime,video/webm,.mp4,.mov,.webm,.m4v" 
        multiple 
        onChange={handleFileInput} 
        className="hidden" 
      />
      
      {/* Toast notifications */}
      <Toast
        message={toast.message}
        type={toast.type}
        isVisible={toast.isVisible}
        onClose={hideToast}
      />
      
      {/* Mobile Recording Info Modal */}
      <AnimatePresence>
        {showMobileRecordingInfo && (
          <>
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              onClick={() => setShowMobileRecordingInfo(false)}
              className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50"
            />
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              className="fixed inset-0 z-50 flex items-center justify-center p-4"
            >
              <div className="w-full max-w-sm bg-[#111] border border-white/10 rounded-2xl p-6 shadow-2xl">
                <div className="flex items-center gap-3 mb-4">
                  <div className="w-10 h-10 rounded-xl bg-[#FF6E3C]/20 flex items-center justify-center">
                    <Smartphone className="w-5 h-5 text-[#FF6E3C]" />
                  </div>
                  <h3 className="text-lg font-semibold text-white">Screen recording is not available on mobile browsers.</h3>
                </div>
                
                <div className="space-y-3 text-sm text-white/70">
                  <p className="font-medium text-white">To record your phone screen:</p>
                  <ol className="list-decimal list-inside space-y-1">
                    <li>Use your phone's built-in screen recorder</li>
                    <li>Upload the recording here</li>
                  </ol>
                  <div className="pt-2 space-y-1 text-xs text-white/50">
                    <p><span className="text-white/70">iOS:</span> Control Center  Screen Recording</p>
                    <p><span className="text-white/70">Android:</span> Quick Settings  Screen Record</p>
                  </div>
                </div>
                
                <button
                  onClick={() => setShowMobileRecordingInfo(false)}
                  className="w-full mt-6 py-2.5 rounded-xl bg-[#FF6E3C] text-white font-medium hover:bg-[#FF8F5C] transition-colors"
                >
                  Close
                </button>
              </div>
            </motion.div>
          </>
        )}
      </AnimatePresence>
    </div>
  );
}
